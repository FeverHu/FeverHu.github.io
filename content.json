{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"https://feverhu.github.io","root":"/"},"pages":[{"title":"友情链接","date":"2022-08-07T03:29:10.627Z","updated":"2022-08-07T03:29:10.627Z","comments":true,"path":"links/index.html","permalink":"https://feverhu.github.io/links/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-08-07T02:19:56.000Z","updated":"2022-08-07T02:21:22.033Z","comments":true,"path":"tags/index.html","permalink":"https://feverhu.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"TEA学习","slug":"TEA学习","date":"2022-08-07T02:04:53.000Z","updated":"2022-08-07T02:23:22.995Z","comments":true,"path":"2022/08/07/TEA学习/","link":"","permalink":"https://feverhu.github.io/2022/08/07/TEA%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"TEA感谢各位师傅，转载连接：https://www.cnblogs.com/sk2rw/p/14797633.html 我做做删减和补充。 简介TEA算法使用64位的明文分组和128位的密钥，使用feistel分组加框架，需要进行32轮循环得到最后的64位密文，其中magic number DELTA是由黄金分割点。 tea算法最关键的是要找到DELTA值和128位的key。 在逆向程序的时候，可以利用ida的插件findcypto识别tea算法。 如上图的程序，可以看出a2就是key，v4-&#x3D;0x61c88647和v4+&#x3D;0x9e3779b9是等价的，显然DELTA就是0x9e3779b9 Tea算法还可以进行魔改，魔改的地方主要是DELTA值，将这个值修改会让很多加密算法识别软件失效，像下面的程序就将DELTA魔改为0x1234567，绕过来peid的插件KANAL的识别。 补充TEA及魔改TEA加密与解密源码： 初级TEA12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt;#include &lt;stdint.h&gt; //加密函数void encrypt (uint32_t* v, uint32_t* k) &#123; uint32_t v0=v[0], v1=v[1], sum=0, i; /* set up */ uint32_t delta=0x9e3779b9; /* a key schedule constant */ uint32_t k0=k[0], k1=k[1], k2=k[2], k3=k[3]; /* cache key */ for (i=0; i &lt; 32; i++) &#123; /* basic cycle start */ sum += delta; v0 += ((v1&lt;&lt;4) + k0) ^ (v1 + sum) ^ ((v1&gt;&gt;5) + k1); v1 += ((v0&lt;&lt;4) + k2) ^ (v0 + sum) ^ ((v0&gt;&gt;5) + k3); &#125; /* end cycle */ v[0]=v0; v[1]=v1;&#125;//解密函数void decrypt (uint32_t* v, uint32_t* k) &#123; uint32_t v0=v[0], v1=v[1], sum=0xC6EF3720, i; /* set up */ uint32_t delta=0x9e3779b9; /* a key schedule constant */ uint32_t k0=k[0], k1=k[1], k2=k[2], k3=k[3]; /* cache key */ for (i=0; i&lt;32; i++) &#123; /* basic cycle start */ v1 -= ((v0&lt;&lt;4) + k2) ^ (v0 + sum) ^ ((v0&gt;&gt;5) + k3); v0 -= ((v1&lt;&lt;4) + k0) ^ (v1 + sum) ^ ((v1&gt;&gt;5) + k1); sum -= delta; &#125; /* end cycle */ v[0]=v0; v[1]=v1;&#125; int main()&#123; uint32_t v[2]=&#123;1,2&#125;,k[4]=&#123;2,2,3,4&#125;; // v为要加密的数据是两个32位无符号整数 // k为加密解密密钥，为4个32位无符号整数，即密钥长度为128位 printf(&quot;加密前原始数据：%u %u\\n&quot;,v[0],v[1]); encrypt(v, k); printf(&quot;加密后的数据：%u %u\\n&quot;,v[0],v[1]); decrypt(v, k); printf(&quot;解密后的数据：%u %u\\n&quot;,v[0],v[1]); return 0;&#125; TEA升级版XTEA增加了更多的密钥表，移位和异或等操作。 XTEA是TEA的扩展，也称做TEAN，它使用与TEA相同的简单运算，同样是一个64位块的Feistel密码，使用128位密钥，建议64轮, 但四个子密钥采取不正规的方式进行混合以阻止密钥表攻击。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758加密前原始数据：1 2 加密后的数据：1347371722 925494771 解密后的数据：1 2 Process returned 0 (0x0) execution time : 0.020 s Press any key to continue. XTEA是TEA的升级版，增加了更多的密钥表，移位和异或操作等等，设计者是Roger Needham, David Wheeler加密过程：算法实现：示例代码：[cpp] view plain copy#include &lt;stdio.h&gt; #include &lt;stdint.h&gt; /* take 64 bits of data in v[0] and v[1] and 128 bits of key[0] - key[3] */ void encipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) &#123; unsigned int i; uint32_t v0=v[0], v1=v[1], sum=0, delta=0x9E3779B9; for (i=0; i &lt; num_rounds; i++) &#123; v0 += (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + key[sum &amp; 3]); sum += delta; v1 += (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + key[(sum&gt;&gt;11) &amp; 3]); &#125; v[0]=v0; v[1]=v1; &#125; void decipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) &#123; unsigned int i; uint32_t v0=v[0], v1=v[1], delta=0x9E3779B9, sum=delta*num_rounds; for (i=0; i &lt; num_rounds; i++) &#123; v1 -= (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + key[(sum&gt;&gt;11) &amp; 3]); sum -= delta; v0 -= (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + key[sum &amp; 3]); &#125; v[0]=v0; v[1]=v1; &#125; int main() &#123; uint32_t v[2]=&#123;1,2&#125;; uint32_t const k[4]=&#123;2,2,3,4&#125;; unsigned int r=32;//num_rounds建议取值为32 // v为要加密的数据是两个32位无符号整数 // k为加密解密密钥，为4个32位无符号整数，即密钥长度为128位 printf(&quot;加密前原始数据：%u %u\\n&quot;,v[0],v[1]); encipher(r, v, k); printf(&quot;加密后的数据：%u %u\\n&quot;,v[0],v[1]); decipher(r, v, k); printf(&quot;解密后的数据：%u %u\\n&quot;,v[0],v[1]); return 0; &#125; XXTEA又称Corrected Block TEA，是XTEA的升级版XXTEA是一个非平衡Feistel网络分组密码，在可变长度块上运行，这些块是32位大小的任意倍数（最小64位），使用128位密钥, 是目前TEA系列中最安全的算法，但性能较上两种有所降低。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;stdio.h&gt; #include &lt;stdint.h&gt; #define DELTA 0x9e3779b9 #define MX (((z&gt;&gt;5^y&lt;&lt;2) + (y&gt;&gt;3^z&lt;&lt;4)) ^ ((sum^y) + (key[(p&amp;3)^e] ^ z))) void btea(uint32_t *v, int n, uint32_t const key[4]) &#123; uint32_t y, z, sum; unsigned p, rounds, e; if (n &gt; 1) /* Coding Part */ &#123; rounds = 6 + 52/n; sum = 0; z = v[n-1]; do &#123; sum += DELTA; e = (sum &gt;&gt; 2) &amp; 3; for (p=0; p&lt;n-1; p++) &#123; y = v[p+1]; z = v[p] += MX; &#125; y = v[0]; z = v[n-1] += MX; &#125; while (--rounds); &#125; else if (n &lt; -1) /* Decoding Part */ &#123; n = -n; rounds = 6 + 52/n; sum = rounds*DELTA; y = v[0]; do &#123; e = (sum &gt;&gt; 2) &amp; 3; for (p=n-1; p&gt;0; p--) &#123; z = v[p-1]; y = v[p] -= MX; &#125; z = v[n-1]; y = v[0] -= MX; sum -= DELTA; &#125; while (--rounds); &#125; &#125; int main() &#123; uint32_t v[2]= &#123;1,2&#125;; uint32_t const k[4]= &#123;2,2,3,4&#125;; int n= 2; //n的绝对值表示v的长度，取正表示加密，取负表示解密 // v为要加密的数据是两个32位无符号整数 // k为加密解密密钥，为4个32位无符号整数，即密钥长度为128位 printf(&quot;加密前原始数据：%u %u\\n&quot;,v[0],v[1]); btea(v, n, k); printf(&quot;加密后的数据：%u %u\\n&quot;,v[0],v[1]); btea(v, -n, k); printf(&quot;解密后的数据：%u %u\\n&quot;,v[0],v[1]); return 0; &#125; 注意！python是大端序， 我们的C语言是小端序。所以需要转化一下。例如： 12345python:b&#x27;\\xbc\\xa5\\xce@\\xf4\\xb2\\xb2\\xe7\\xa9\\x12\\x9d\\x12\\xae\\x10\\xc8[=\\xd7\\x06\\x1d\\xdcp\\xf8\\xdc&#x27;c++:uint32_t v[6]= &#123;0x40cea5bc,0xe7b2b2f4,0x129d12a9,0x5bc810ae,0x1d06d73d,0xdcf870dc&#125;; &quot;flag&quot; 0x67616c66","categories":[],"tags":[{"name":"reverse","slug":"reverse","permalink":"https://feverhu.github.io/tags/reverse/"}]},{"title":"angr学习","slug":"angr学习","date":"2022-08-07T01:16:54.000Z","updated":"2022-08-07T02:23:32.671Z","comments":true,"path":"2022/08/07/angr学习/","link":"","permalink":"https://feverhu.github.io/2022/08/07/angr%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"angr学习angr基本脚本一、非命令行输入1234567891011121314151617181920212223242526import angrimport sysdef Go(): path_to_binary = &quot;*****&quot; project = angr.Project(path_to_binary, auto_load_libs=False) initial_state = project.factory.entry_state() simulation = project.factory.simgr(initial_state) #一般我会先查看程序起始地址，64位程序可能是0x400000，32位可能是0x800000 #print(project.entry) print_good_address = 0x4009E7 simulation.explore(find=print_good_address) if simulation.found: solution_state = simulation.found[0] solution = solution_state.posix.dumps(sys.stdin.fileno()) # 大概意思是dump出输入 print(solution) else: raise Exception(&#x27;Could not find the solution&#x27;)if __name__ == &quot;__main__&quot;: Go() #path_to_binary = &quot;oruga&quot; #project = angr.Project(path_to_binary, auto_load_libs=False) #print(project.entry) 二、使用命令行参数情况12345678910111213141516171819202122232425import angrimport sysimport claripydef Go(): path_to_binary = &quot;chall&quot; project = angr.Project(path_to_binary, auto_load_libs=False) #print(project.entry) argv1 = claripy.BVS(&#x27;argv1&#x27;,33*8) initial_state = project.factory.entry_state(args=[&quot;./chall&quot;, argv1]) simulation = project.factory.simgr(initial_state) print_good_address = 0x400817 simulation.explore(find=print_good_address) if simulation.found: solution_state = simulation.found[0].solver.eval(argv1) # 打印结果 solution = solution_state.to_bytes(33,&quot;big&quot;) print(solution) else: raise Exception(&#x27;Could not find the solution&#x27;)if __name__ == &quot;__main__&quot;: Go() 代替scanf：123456789101112131415161718192021222324252627282930313233343536373839import angrimport sysimport claripydef main(argv): path_to_binary = &#x27;ROR.exe&#x27; # :string project = angr.Project(path_to_binary) initial_state = project.factory.entry_state() class ReplacementScanf(angr.SimProcedure): def run(self, format_string, param0): scanf0 = claripy.BVS(&#x27;scanf0&#x27;, 8 * 80) scanf0_address = param0 print(scanf0_address) self.state.memory.store(scanf0_address, scanf0, endness = project.arch.memory_endness) self.state.globals[&#x27;solutions&#x27;] = scanf0 scanf_symbol = &#x27;scanf&#x27; project.hook_symbol(scanf_symbol, ReplacementScanf()) simulation = project.factory.simgr(initial_state) def is_successful(state): stdout_output = state.posix.dumps(sys.stdout.fileno()) return &#x27;Congratulations&#x27;.encode() in stdout_output simulation.explore(find=is_successful) if simulation.found: solution_state = simulation.found[0] stored_solutions = solution_state.globals[&#x27;solutions&#x27;] scanf0_solution = solution_state.solver.eval(stored_solutions) print(scanf0_solution) else: raise Exception(&#x27;Could not find the solution&#x27;)if __name__ == &#x27;__main__&#x27;: main(sys.argv) angr练习十八道02_angr_find_condition本题知识点：在没有地址情况下，利用字符串来确定寻找地址和规避地址。 ida： 12345678910111213def is_successful(state): # Dump whatever has been printed out by the binary so far into a string. stdout_output = state.posix.dumps(sys.stdout.fileno()) # Return whether &#x27;Good Job.&#x27; has been printed yet. # (!) return b&#x27;Good Job.&#x27; in stdout_output # :booleandef should_abort(state): stdout_output = state.posix.dumps(sys.stdout.fileno()) return b&#x27;Try again.&#x27; in stdout_output # :booleansimulation.explore(find=is_successful, avoid=should_abort) 通过 stdout_output = state.posix.dumps(sys.stdout.fileno())和return b&#39;Good Job.&#39; in stdout_output # :boolean来判断是否到底指定情况的地址，适用于多种情况而非一个地址的情况。","categories":[],"tags":[{"name":"reverse","slug":"reverse","permalink":"https://feverhu.github.io/tags/reverse/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-07-31T06:56:59.204Z","updated":"2022-08-07T02:22:07.305Z","comments":true,"path":"2022/07/31/hello-world/","link":"","permalink":"https://feverhu.github.io/2022/07/31/hello-world/","excerpt":"","text":"感谢牛逼的hexo！自带的hello world就留着致敬吧！^_^ Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[{"name":"tags","slug":"tags","permalink":"https://feverhu.github.io/tags/tags/"}]}],"categories":[],"tags":[{"name":"reverse","slug":"reverse","permalink":"https://feverhu.github.io/tags/reverse/"},{"name":"tags","slug":"tags","permalink":"https://feverhu.github.io/tags/tags/"}]}